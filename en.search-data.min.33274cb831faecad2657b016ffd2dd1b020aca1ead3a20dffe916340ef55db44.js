'use strict';(function(){const indexCfg={cache:true,split:/[^a-zа-яё0-9\w]/gi};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/avito-android/posts/lint-worker-api-workaround/','title':"Android lint and Gradle worker API workaround",'section':"Blog",'content':"Workaround for Android lint that doesn\u0026rsquo;t use Gradle Worker API #  Issue #145235363\nProblem #  We have a lot of modules in the project, and things build in parallel very well. However, there is a contention between Android lint and UI-tests in CI builds. Both tasks are on a final application module.\nWe use workers to parallelize different UI-testing tasks and enable Gradle workers API for available Android Gradle plugin tasks.\nAndroid lint does not use Gradle Worker API yet and blocks any of these optimizations on most occasions.\nIt is so, because Gradle holds module (project) lock, and even if your task use workers, it should acquire the lock to start or report finish.\nSo it will parallelize as nice as you might expect only if all tasks running on module use workers, or non-worker task is fast enough to even bother.\nTasks report finish time later than actual: gradle #8630    mermaid.initialize({ flowchart: { useMaxWidth:true } });  gantt title Lint blocks instrumentation to start dateFormat YYYY-MM-DD axisFormat %j section project package :package, 1000-01-01, 11d lint :lint, 1000-01-02, 10d instrumentation :after lint package, 10d Solution #  We ended up with a kinda dirty and in-theory unstable hack, but it works well.\nLet\u0026rsquo;s take a look only on final application module tasks:\n Long tasks supporting workers API (good tasks) must start as soon as all its dependencies ready. It will release a lock right after the start Android lint (bad task) should start right after it, holding a lock until the end Even if good tasks finished before lint we end a whole build in much more optimal time than consequentially  gantt title Lint runs in parallel with instrumentation dateFormat YYYY-MM-DD axisFormat %j section project package :package, 1000-01-01, 3d instrumentation :after package, 11d lint :lint, 1000-01-05, 10d Implementation #  We have introduced preInstrumentation task for UI-tests, that depends on the same tasks as instrumentation one\u0026rsquo;s, but doing nothing other than mustRunAfter point to lint task, moving it next to UI-tests.\n"});index.add({'id':2,'href':'/avito-android/posts/open-source-introduction/','title':"Open source for CI/CD and test infrastructure for Android",'section':"Blog",'content':"Open source: CI/CD and test infrastructure for Android #  Avito.ru is the second biggest classified in the world. We have moved our Android infrastructure into open source: Gradle plugins, emulators, and test libraries. Our code will be useful in automating CI/CD and will also facilitate the coding and support of autotests.\nIn this review, we will explain why we decided to move into open source, present the central libraries of the project, and suggest whom to contact with any questions. We will analyze in detail the individual libraries, Gradle plugins, and our development approaches in future posts.\nWho we are and what we do #  We are developing solutions for Android as part of the Speed platform team. There are four of us:\nSergey Boishtyan\nSenior engineer\nsboishtyan\n Dima Voronin\nLead engineer\nDmitriVoronin\n Eugene Krivobokov\nSenior engineer\neugene_kr\n Daniil Popov\nSenior engineer\nInt02h\n  We are in charge of delivering changes in all Avito’s Android apps to users as fast as possible. Our area of responsibility covers:\n Local project activities: making sure that everything is quickly built and the IDE runs fast. CI pipeline: tests and all possible checks. CD: tools for release engineers.  Why open source #  We wanted not only to mirror the code in the open source repository on GitHub but also to learn something new and make a contribution to the software engineering community. There were five key reasons to move the project into open source:\n Get feedback. Influence industry standards. Learn something new. Influence third-party libraries. Promote our personal brands.  Let\u0026rsquo;s discuss these one by one.\nGet feedback and make the code easier to reuse #  We do the tooling for Avito’s engineers, and our users need all solutions to simply work. We lack the outsider perspective of developers who work on similar problems. We need them to point out issues in the internal implementation and the convenience of connecting to our project.\nWe have already seen how moving the code to GitHub highlighted the problems of reuse. When you understand that other companies can use your project, you start looking at the architecture differently. Reusing code is not the ultimate target. But this external criterion says a lot about the quality of the architecture and its flexibility.\nInfluence the industry standards #  We have been developing infrastructure for mobile apps since 2017 and regularly make talks at local developer conferences and meetups.\nWe always wanted to share the code in addition to our words and allow others to reuse it. Indeed, many Android developers face similar challenges:\n How to write effective autotests. How to run these in pull requests. How to maintain infrastructure cost-effectively.  There are no generally accepted, universal solutions for these tasks — each company solves them in its way. We share our best practices so that developers of new projects do not have to collect bit by bit information on testing mobile apps and building CI/CD. We want to offer ready-made solutions for routine problems instead of having to invent the wheel. And even if nobody uses the project code in its original form, developers will be able to see our approaches and improve their libraries.\nLearn by teaching #  Just moving the code into open source is not enough. Practices, approaches, methods of troubleshooting, and making decisions — this is what is essential. Sharing these, we verify whether our ideas and ready-made solutions work outside of Avito.\nInfluencing third-party libraries and fixing their problems faster #  Imagine you are facing a problem in Android or a library and cannot find a workaround. You need help from the community or the code’s authors. You asked a question on Stack Overflow, filed a bug report in Google IssueTracker, described everything in detail, but the problem won’t reproduce. You are asked to share a test case. All this takes extra time.\nOpen source helps you create a reproducible example faster. We have a test app, which uses part of the infrastructure. Its main function is dogfooding, i.e. making sure as early as possible using a simple and isolated case that everything works. But this same app makes it easier to demonstrate bugs. When we show a reproducible example in a third-party library, it becomes easier for its developer to understand what is going on. This increases the chances that the developers will fix the issue.\nThe popularity of an open source project also increases the likelihood that you will be paid attention to. When an issue in a library has many stars and users, this increases the pressure, and the issue becomes more difficult to ignore. Achieving this without open source is more challenging — the app has to be super popular, or one should make oneself known.\nPR and personal motivation #  Last but not least, is personal benefit. Everybody benefits when their daily work gains publicity. Avito grabs public attention by offering a useful product, and we promote our personal brands as engineers and develop additional motivation for working. We no longer need to use our free time to work on our own projects or commits in third-party open source libraries.\nWhat’s in the open source #  We have made available in the GitHub repository almost all of our Android and CI/CD testing infrastructure. To make it easier for other developers to navigate the project, we grouped all its modules by function:\n Gradle plugins. Libraries for Android testing modules. Emulators.  Let’s discuss some of the most important libraries.\nTest runner #  This is a Gradle plugin to run instrumentation tests. The closest analog is Marathon, but our plugin runs only under Android.\nTest runner:\n Specifies which tests to run. Filtering by annotations, by packages, by the results of the last run is supported. Specifies which emulators to run tests on. Backs these up to Kubernetes or connects to local emulators. Sets test restart conditions. Sends a final report with the test run results.  The results are stored in custom TMS (test management system), which is not open source. We are working on the possibility of connecting to a different implementation.\nImpact analysis #  We have about 1,600 instrumentation tests and 10K unit tests. We would like to run all the tests for any code change, but this is not possible — such a test run would take too much time.\nA simple solution is to manually subdivide the tests into subsets, for example, smoke tests, fast, slow tests, and run only one set at a time. But with this approach, there is always a risk of missing an error, because it is not clear which set of tests is optimal. An ideal solution would be to understand which minimum test set can verify all changes. This is known as test impact analysis.\nWe wrote a Gradle plugin, which searches for changes in modules, parses tests, and determines which ones to run.\nFor more details of the main modules and approaches, see the project documentation. It is still incomplete, and not everything is translated. We want to make the documentation easier to understand, and need your help. Tell us what to improve and correct in the documentation in our Telegram chat.\nHow our libraries can be useful #  Since there are many components in our project, its applications depend on your needs. If you are working on a similar problem or just want to understand the technology better — feel free to contact us in GitHub or our Telegram chat. We will share what we know, try to help, and show relevant examples.\nYou can ask anything:\n How do we handle unstable tests? Why so much code? It makes no sense. Why is all the code in Gradle plugins and not in python scripts?  If you want to use a specific module, you can try it in the test app. Currently, it shows an example of using our test runner.\nUnfortunately, we still have few examples of reuse in other projects, so integration may reveal yet unknown limitations. Let us know if this happens, and we we will see what to fix.\nConclusion #  In our upcoming posts, we plan to talk about:\n Our test runner. Test anatomy — what happens from the moment of clicking “Run” in the IDE up to the test completion moment. How we deal with the instability of tests and infrastructure. Our approaches to writing infrastructure. How we reduced the release time from month to week.  We want to discuss some more general topics, too:\n How to start writing tests. Fundamentals of testing for beginners — common approaches and technologies.  Comment to let us know what you would like to read about. So we will know which topic to cover first.\n"});index.add({'id':3,'href':'/avito-android/docs/release/','title':"Release",'section':"Docs",'content':"Infrastructure release #  This page contains Avito specific details  We publish releases to Bintray.\nPublishing a new release #   Check current status of Infra Gradle plugins configuration compatibility with Avito.\nIf it is Failed you could release from previous Succeed commits or fix compatibility problems. Check current status of Nightly Avito integration build.\nIf it is Failed you could release from previous Succeed commits or fix problems. Checkout a release branch with a name equals to projectVersion. For example, 2020.9.\nThis branch must be persistent. It is used for automation. Manually run Integration build on the release branch. Manually run Github publish configuration on the release branch. Make a PR to an internal avito repository with the new version of infrastructure. Checkout a new branch and make a PR to github repository:  Change infraVersion property in the ./gradle.properties to the new version Bump up a projectVersion property in the ./subprojects/gradle.properties to the next version   Create a new release against the release branch. (Managing releases in a repository)\nYou can use a draft release to prepare a description in advance.  Known issues #  Failed publishing to Bintray #  Uploading to Bintray is flaky. You can face different issues:\n NoHttpResponseException: api.bintray.com:443 failed to respond #325 Could not upload to https://api.bintray.com/...: HTTP/1.1 405 Not Allowed nginx  In this case artifacts can be uploaded partially, only pom for instance.\nTry to upload it with overriding:\nEnable BintrayExtension.override in a buildscript. Upload problematic artifact:\n./gradlew -p subprojects :\u0026lt;module\u0026gt;:bintrayUpload --no-parallel --stacktrace  Can\u0026rsquo;t find an artifact in an internal Artifactory #  How it looks:\n Bintray has expected artifacts: pom, jar/aar, sources.jar Gradle can\u0026rsquo;t find it in Artifactory  \u0026gt; Could not resolve all artifacts for configuration \u0026#39;:classpath\u0026#39;. \u0026gt; Could not find com.avito.android:runner-shared:2020.16. Searched in the following locations: - file:/home/user/.m2/repository/com/avito/android/runner-shared/2020.16/runner-shared-2020.16.pom - http://\u0026lt;artifactory\u0026gt;/artifactory/bintray-avito-maven/com/avito/android/runner-shared/2020.16/runner-shared-2020.16.pom Probable reasons:\n The file is not downloaded by Artifactory yet. Such files look in web UI like empty references: runner-shared-2020.16.jar-\u0026gt; - - - - (empty size) When you use a partially uploaded release, Artifactory might cache the wrong state. It seems that Artifactory caches it for some time, but we don\u0026rsquo;t know exactly and how to invalidate it.  Actions:\n Download this file manually in the browser or CLI.\nIf the file downloaded successfully, refresh a local cache via --refresh-dependencies. If it didn\u0026rsquo;t help, bump up a minor release version and make a new release.  Local integration tests against Avito #  Using mavenLocal #   Run ./gradlew publishToMavenLocal -PprojectVersion=local -p subprojects in github repository. Run integration tests of your choice in avito with specified test version  Using compositeBuild #  Run from Avito project directory\n./gradlew \u0026lt;task\u0026gt; -Pavito.useCompositeBuild=true -Pavito.compositeBuildPath=\u0026lt;avito-android-infra/subprojects dir on your local machine\u0026gt; CI integration tests against Avito #   Choose configuration from existed Run build.\nIf you need to test unmerged code, select a custom build branch.\nYou will see branches from both repositories:   By default, build uses develop from github against develop from avito If you pick a branch from avito, it will run against develop on github If you pick a branch from github, it will run against develop on avito To build both projects of special branch, they should have the same name  If you want to run a real CI build against not published release, you could publish it manually as a temporary version to the internal Artifactory:\n./gradlew -p subprojects publishToArtifactory -PprojectVersion=\u0026lt;projectVersion\u0026gt;-integration-01 -Dorg.gradle.internal.publish.checksums.insecure=true Or using Publish to Artifactory CI configuration.\nCI integration configurations #   fast check configuration (internal) - pull request\u0026rsquo;s builds integration check - currently, contains the biggest amount of integration checks nightly integration check - the same as integration check but uses more Android emulators Gradle configuration compatibility check - checks the configuration compatibility of our Gradle plugins with Avito repo  "});index.add({'id':4,'href':'/avito-android/docs/test/screenchecks/','title':"Screen Checks",'section':"Docs",'content':"Screen checks #  Screen is abstraction that represents Activity, Fragment or View in tests.\nScreen has a property checks of type ScreenChecks with single function isScreenOpened. \\ ScreenChecks has a property checkOnEachScreenInteraction. It makes automatic execution isScreenOpened on each interaction with ViewElement on that Screen. \\\nDefault Screen.checks #  checkOnEachScreenInteraction works only if:\n your Screen extends from PageObject your ViewElements is created by element(Matcher) function   interface Screen { val checks: ScreenChecks get() = StrictScreenChecks( screen = this, checkOnEachScreenInteraction = false ) } Already existed ScreenChecks #   StrictScreenChecks. isScreenOpened checks if rootView.id equals to Screen.rootId  How to customize isScreenOpened check #  With writing a custom check #  If your Screen doesn\u0026rsquo;t support StrictScreenChecks.isScreenOpened behavior  import com.avito.android.screen.Screen class MyScreen : Screen { override val checks = MyScreenChecks() class MyScreenChecks : ScreenChecks { override fun isScreenOpened() { TODO(\u0026#34;Your check logic\u0026#34;) } } } With extending from existent check #  If StrictScreenChecks.isScreenOpened isn\u0026rsquo;t enough for your Screen  import com.avito.android.screen.Screen class MyScreen : Screen { override val checks = MyScreenChecks() class MyScreenChecks(screen: Screen) : StrictScreenChecks(screen = screen) { override fun isScreenOpened() { super.isScreenOpened() TODO(\u0026#34;Your check logic\u0026#34;) } } } How to make isScreenOpened executes on each interaction with ViewElements #  We recommend to set checkOnEachScreenInteraction true. In the future, we will make this behavior default.  If your ScreenChecks extends from StrictScreenChecks #  import com.avito.android.screen.Screen class MyScreen : Screen { override val checks = MyScreenChecks() class MyScreenChecks(screen: Screen) : StrictScreenChecks(screen = screen, checkOnEachScreenInteraction = true /*true by default*/) {} } That\u0026rsquo;s all StrictScreenChecks enable checkOnEachScreenInteraction\nIf your ScreenChecks extends from default ScreenChecks interface #  import com.avito.android.screen.Screen class MyScreen : Screen { override val checks = MyScreenChecks() class MyScreenChecks : ScreenChecks { override val checkOnEachScreenInteraction = true } } How to use ScreenChecks.isScreenOpened in your code if checkOnEachScreenInteraction = false? #  This code could lead you to making mistakes:\n You could forget to add the check manually You could add the check in to place belonging to another Screen  This code increases a cognitive pressure\n import com.avito.android.screen.Screen val screen: Screen = TODO(\u0026#34;Logic for initializing your Screen\u0026#34;) screen.checks.isScreenOpened() How to use the same Screen with different behavior #  It may be useful when one Screen contains different UI states.  fun Screen.myScreen(title: String? = null) = PublishParamsScreen(title) class PublishParamsScreen(val title: String? = null) : PageObject(), Screen { class MyScreenChecks(screen: Screen, private val title: String?) : StrictScreenChecks(screen = screen) { override fun isScreenOpened() { super.isScreenOpened() if (title != null) { title.checks.withText(title) } } } } "});index.add({'id':5,'href':'/avito-android/docs/test/snackbar/','title':"Snackbar",'section':"Docs",'content':"Snackbar #  Why do we need a custom component for snackbar testing?\nWe can\u0026rsquo;t predict when snackbar will appear or disappear because we have no API to watch that behaviour.\nSo it\u0026rsquo;s hard to realize our test failed because: there are no snackbars, snackbar has already disappeared or it hasn\u0026rsquo;t appeared yet.\nHow our library works?\nWe remember all snackbar showings through the test and give you an ability to check that snackbar showing history.\nHow to test snackbars with our library? #   Add dependencies to Gradle  Kotlin Add to your build.gradle.kts\ndependencies { implementation(\u0026#34;com.avito.android:snackbar-proxy:$version\u0026#34;) implementation(\u0026#34;com.google.android.material:material:$androidXVersion\u0026#34;) androidTestImplementation(\u0026#34;com.avito.android:snackbar-rule:$version\u0026#34;) } Groovy Add to your build.gradle\ndependencies { implementation(\u0026#34;com.avito.android:snackbar-proxy:$version\u0026#34;) implementation(\u0026#34;com.google.android.material:material:$androidXVersion\u0026#34;) androidTestImplementation(\u0026#34;com.avito.android:snackbar-rule:$version\u0026#34;) }  Replace com.google.android.material.snackbar.Snackbar.show() by our wrapper function  import com.avito.android.snackbar.proxy.showSnackbar import com.google.android.material.snackbar.Snackbar val snackbar: Snackbar = TODO(\u0026#34;Make a snackbar\u0026#34;) snackbar.showSnackbar() Use our com.avito.android.test.app.second.SnackbarRule in tests  import com.avito.android.test.app.second.SnackbarRule import org.junit.Test import org.junit.Rule class SomeTest { @get:Rule private val rule = SnackbarRule() @Test fun test() { // test logic  rule.assertIsShownWith(\u0026#34;text\u0026#34;) rule.assertIsShownWith(Matchers.Is(\u0026#34;text\u0026#34;)) rule.assertIsShownLastWith(\u0026#34;text\u0026#34;) rule.assertIsShownLastWith(Matchers.Is(\u0026#34;text\u0026#34;)) } } "});index.add({'id':6,'href':'/avito-android/docs/analytics/analytics/','title':"Analytics",'section':"Docs",'content':"Analytics #  This page contains Avito specific details  Для сбора данных используем собственные транспорты:\n Clickstream (internal) Statsd  Поверх транспорта есть готовые обертки под конкретные задачи:\n Performance аналитика  "});index.add({'id':7,'href':'/avito-android/docs/infrastructure/','title':"Android infrastructure",'section':"Docs",'content':"Avito android infrastructure on github #  Monorepo of all tooling to continuously test and deliver apps to users.\nModules #  Gradle plugins #  To use plugins in your project:\nIn the settings.gradle:\npluginManagement { repositories { maven { name = \u0026#34;Avito bintray\u0026#34; url = \u0026#34;https://dl.bintray.com/avito/maven\u0026#34; } } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } } avitoToolsVersion could be exact version, or property in project\u0026rsquo;s gradle.properties.\nThe latest version could be found on project\u0026rsquo;s release page.\nPlugins:\n :artifactory-app-backup - Gradle plugin to back up build artifacts in artifactory :build-metrics - Gradle plugin for gathering build metrics and deliver them to grafana :build-properties - Gradle plugin to deliver custom build parameters to Android assets :buildchecks - Gradle plugin to early detection of build problems :cd :design-screenshots - Gradle plugin, extended tasks to support screenshot testing on top of our :instrumentation plugin :feature-toggles - Gradle plugin to extract feature toggles values from code and report it as build artifact :impact, :impact-shared - Gradle plugin to search parts of the project we can avoid testing based on diff. :instrumentation-tests - Gradle plugin to set up and run instrumentation tests on Android :instrumentation-test-impact-analysis, :ui-test-bytecode-analyser - Gradle plugin to search ui tests we can avoid based on impact-plugin analysis :kotlin-root - Gradle plugin to configure kotlin tasks for internal project :lint-report - Gradle plugin merging lint reports from different modules :module-types - Gradle plugin to prevent modules go to wrong configurations (android-test module as an app\u0026rsquo;s implementation dependency for example) :code-ownership - Gradle plugin to prevent dependency on other team\u0026rsquo;s private modules :prosector - Gradle plugin and client for security service :qapps - Gradle plugin to deliver apps to internal distribution service, see QApps :robolectric- Gradle plugin to configure robolectrtic for internal project :room-config - Gradle plugin to configure room for internal project :signer - Gradle plugin for internal app signer  Build script dependencies #   :android - Android Gradle plugin extensions, and Android SDK wrapper // todo separate :bitbucket - Bitbucket client to deliver checks results right into pull request context via code insights and comments :docker - docker client to work with docker daemon from Gradle :files - utils to work with files and directories :git - git client to work within Gradle See impact analysis :kotlin-dsl-support - Gradle api extensions //todo rename :kubernetes - kubernetes credentials config extension :logging - custom logger to serialize for Gradle workers //todo no longer a problem, remove :pre-build - extensions to add tasks to the early stages of build :process - utils to execute external commands from Gradle :runner:client, :runner:service, :runner:shared, :runner:shared-test - instrumentation tests runner :sentry-config - sentry client config extension :slack - slack client to work within Gradle plugins :statsd-config - statsd client config extension :teamcity - wrapper for teamcity client and service messages :test-project - Gradle Test Kit project generator and utilities :test-summary - test suite summary writer :trace-event - client for trace event format :upload-cd-build-result - client for internal \u0026ldquo;Apps release dashboard\u0026rdquo; service :upload-to-googleplay - wrapper for google publishing api :utils - //todo remove  Android testing modules #  Code that goes in androidTestImplementation configuration and runs on emulators.\n :junit-utils - //todo move to common :mockito-utils - //todo move to common :resource-manager-exceptions - //todo remove :test-annotations - annotations to supply meta information for reports and test management system :test-app - app we are using to test :ui-testing- libraries :test-inhouse-runner - custom android junit runner :test-report - client to gather test runtime information for reporting :ui-testing-core - main ui testing library, based on espresso :ui-testing-maps - addon for main library to test google maps scenarios :websocket-reporter - client to gather websocket info for reporting  Android libraries #   :proxy-toast - helps with testing toasts  Common modules #  Shared modules between android-test and Gradle.\n :file-storage - client for internal file storage client, used to store screenshots, videos and other binary stuff :okhttp - okhttp extensions :sentry - sentry client :statsd - statsd client :test-okhttp - wrapper for okhttpmockwebserver :time - simple time api  "});index.add({'id':8,'href':'/avito-android/docs/checks/androidlint/','title':"Android Lint",'section':"Docs",'content':"Android Lint #  This page contains Avito specific details  We use Android lint to check applications in CI.\nBy default, we check only applications. It\u0026rsquo;s no use checking libraries in isolation.\nHow to run lint locally #  ./gradlew :\u0026lt;app module\u0026gt;:lintRelease\nConfigure lint to suppress warnings #  You can use default capabilities of Android lint (Configure lint to suppress warnings).\n @SuppressLint annotation in the code tools:ignore attribute in XML files lint.xml config file in an application module  Try to minimize a scope of suppressing. It reduces the risk of suppressing other problems accidentally.\nConfigure lint to run in CI #  Add a lint build step to a build in build.gradle\nfastCheck { lint {} } Writing a custom lint check #  This section contains Avito specific information  All customs Android lint checks are in lint-checks (internal) module.\nHow to start:\n Static Analysis with Android Lint by Tor Norbye (mDevCamp 2019) Sample project Install PsiViewer IDE plugin KotlinConf 2018 - Writing IntelliJ Plugins for Kotlin by Alec Strong \u0026amp; Egor Andreevici: Android Lint and IDE plugins use common abstractions to work with AST.  "});index.add({'id':9,'href':'/avito-android/docs/ide/templates/','title':"Android Studio templates",'section':"Docs",'content':"Android Studio templates #  Запустите install_templates.sh или скопируйте папку вручную из ./templates в $ANDROID_STUDIO_DIR/plugins/android/lib/templates/other\n"});index.add({'id':10,'href':'/avito-android/docs/cd/artifacts/','title':"Artifacts",'section':"Docs",'content':"Артефакты сборки #  This page contains Avito specific details  Где храним артефакты? #  Используем несколько хранилищ:\n Artifactory  feature-toggles.json api.json staging apk   QApps Play market/Play console  релизный aab релизный proguard mapping   Teamcity Android PR checks  Вкладка Artifacts у билда Все файлы pull request Живет ~ 1 месяц   Teamcity Android Release  Вкладка Artifacts у билда Все файлы релизной сборки Живет ~ 1 месяц    "});index.add({'id':11,'href':'/avito-android/docs/projects/buildchecks/','title':"Build checks Gradle plugin",'section':"Docs",'content':"Build checks Gradle plugin #  This plugin verifies common build problems with environment and project configuration.\nGetting started #  Apply the plugin in the root build script:\nplugins { id(\u0026#34;com.avito.android.buildchecks\u0026#34;) } In the settings.gradle:\npluginManagement { repositories { maven { name = \u0026#34;Avito bintray\u0026#34; url = \u0026#34;https://dl.bintray.com/avito/maven\u0026#34; } } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } } avitoToolsVersion could be exact version, or property in project\u0026rsquo;s gradle.properties.\nThe latest version could be found on project\u0026rsquo;s release page.\nKotlin build.gradle.kts\nbuildChecks { androidSdk { compileSdkVersion = 29 revision = 5 } javaVersion { version = JavaVersion.VERSION_1_8 } uniqueRClasses { enabled = false } } Groovy build.gradle\nbuildChecks { androidSdk { compileSdkVersion = 29 revision = 5 } javaVersion { version = JavaVersion.VERSION_1_8 } uniqueRClasses { enabled = false } }  That\u0026rsquo;s all for a configuration. Run it manually to verify that it works:\n./gradlew checkBuildEnvironment The plugin will run it automatically on every build.\nConfiguration #  Enable single check #  Kotlin build.gradle.kts\nbuildChecks { enableByDefault = false androidSdk { compileSdkVersion = 29 revision = 5 } } Groovy build.gradle\nbuildChecks { enableByDefault = false androidSdk { compileSdkVersion = 29 revision = 5 } }  Disable single check #  Kotlin build.gradle.kts\nbuildChecks { androidSdk { enabled = false } } Groovy build.gradle\nbuildChecks { androidSdk { enabled = false } }  Disable all checks #  Kotlin build.gradle.kts\nbuildChecks { enableByDefault = false } Groovy build.gradle\nbuildChecks { enableByDefault = false }  Disable plugin #  To completely disable the plugin add a Gradle property:\navito.build-checks.enabled=false Checks #  Java version #  The Java version can influence the output of the Java compiler. It leads to Gradle remote cache misses.\nThis check forces the same version for all builds.\nKotlin build.gradle.kts\nbuildChecks { javaVersion { version = JavaVersion.VERSION_1_8 } } Groovy build.gradle\nbuildChecks { javaVersion { version = JavaVersion.VERSION_1_8 } }  Android SDK version #  Android build tools uses android.jar ($ANDROID_HOME/platforms/android-\u0026lt;compileSdkVersion\u0026gt;/android.jar).\nThe version can be specified only without a revision (#117789774). Different revisions lead to Gradle remote cache misses. This check forces the same revision:\nKotlin build.gradle.kts\nbuildChecks { androidSdk { compileSdkVersion = 29 revision = 5 } } Groovy build.gradle\nbuildChecks { androidSdk { compileSdkVersion = 29 revision = 5 } }  macOS localhost lookup #  On macOs java.net.InetAddress#getLocalHost() invocation can last up to 5 seconds instead of milliseconds (thoeni.io/post/macos-sierra-java). Gradle has a workaround but it works only inside Gradle\u0026rsquo;s code.\nTo diagnose the problem manually use thoeni/inetTester.\nTo fix the problem use this workaround:\n Find your computer\u0026rsquo;s name - Find your computer\u0026rsquo;s name and network address Add it to /etc/hosts config:  127.0.0.1 localhost \u0026lt;your_host_name\u0026gt;.local ::1 localhost \u0026lt;your_host_name\u0026gt;.local Reboot the computer Check again by thoeni/inetTester  This check automatically detects the issue:\nKotlin build.gradle.kts\nbuildChecks { macOSLocalhost { } } Groovy build.gradle\nbuildChecks { macOSLocalhost { } }  Dynamic dependency version #  Dynamic versions, such as \u0026ldquo;2.+\u0026rdquo;, and snapshot versions force Gradle to check them on a remote server. It slows down a configuration time and makes build less reproducible.\nThis check forbids dynamic dependency versions.\nKotlin build.gradle.kts\nbuildChecks { dynamicDependencies { } } Groovy build.gradle\nbuildChecks { dynamicDependencies { } }  Unique R classes #  If two Android modules use the same package, their R classes will be merged. While merging, it can unexpectedly override resources. It happens even with android.namespacedRClass.\nTo forbid merged R files use this check:\nKotlin build.gradle.kts\nplugins { id(\u0026#34;com.avito.android.buildchecks\u0026#34;) id(\u0026#34;com.avito.android.impact\u0026#34;) // this check requires impact analysis } buildChecks { uniqueRClasses { } // enabled by default } Groovy build.gradle\nplugins { id(\u0026#34;com.avito.android.buildchecks\u0026#34;) id(\u0026#34;com.avito.android.impact\u0026#34;) // this check requires impact analysis } buildChecks { uniqueRClasses { } // enabled by default }  Gradle daemon reusage #  Gradle can run multiple daemons for many reasons.\nIf you use buildSrc in the project with standalone Gradle wrapper, this check will verify common problems to reuse it.\nKotlin build.gradle.kts\nbuildChecks { gradleDaemon { } } Groovy build.gradle\nbuildChecks { gradleDaemon { } }  Module types #  This check force to apply module-types Gradle plugin in all modules. It prevents modules go to wrong configurations (android-test module as an app’s implementation dependency for example).\nKotlin build.gradle.kts\nbuildChecks { moduleTypes { enabled = true // disabled by default  } } Groovy build.gradle\nbuildChecks { moduleTypes { enabled = true // disabled by default  } }  Gradle properties #  This check contains Avito specific details  This check detects if you override Gradle project property by command-line. It sends mismatches to statsd. This information helps to see frequently changed propeties that can lead to remote cache misses.\nKotlin build.gradle.kts\nbuildChecks { gradleProperties { enabled = true // disabled by default  } } Groovy build.gradle\nbuildChecks { gradleProperties { enabled = true // disabled by default  } }  Incremental KAPT #  This check verifies that all KAPT annotation processors support incremental annotation processing if it is enabled (kapt.incremental.apt=true). Because if one of them does not support it then whole incremental annotation processing won\u0026rsquo;t work at all.\nSupported processors:\n Room  Incremental KAPT check has three modes:\n \u0026quot;none\u0026quot; \u0026ndash; check is disable \u0026quot;warning\u0026quot; \u0026ndash; prints warning in build log (default behaviour) \u0026quot;fail\u0026quot; \u0026ndash; fail whole build  Kotlin build.gradle.kts\nbuildChecks { incrementalKapt { mode = \u0026#34;fail\u0026#34; } } Groovy build.gradle\nbuildChecks { incrementalKapt { mode = \u0026#34;fail\u0026#34; } }  Room #  Room supports incremental annotation processing if all of the following conditions are met:\n room.incremental it set to true or com.avito.android.room-config Gradle-plugin is applied You use Java 11 and higher or use JDK embedded in Android Studio 3.5.0-beta02 and higher. For more info about these restrictions read the documentation for the method methodParametersVisibleInClassFiles in RoomProcessor sources  If you use IntelliJ IDEA or build a project from the command line you have to set up JAVA_HOME environment variable to reference the path to embedded JDK in Android Studio. You can add to ~/.gradle/gradle.properties line like this:\norg.gradle.java.home=/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home This path can be retrieved from Project Structure \u0026gt; SDK Location \u0026gt; JDK location in Android Studio.\n"});index.add({'id':12,'href':'/avito-android/docs/projects/buildproperties/','title':"Build properties Gradle plugin",'section':"Docs",'content':"Build properties Gradle plugin #  Sometimes you need to inspect information about the current build in your app code. The conventional way is to use custom fields in a BuildConfig or resource values.\nandroid { buildTypes { release { buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;GIT_COMMIT\u0026#34;, \u0026#34;\\\u0026#34;${commit}\\\u0026#34;\u0026#34;) resValue(\u0026#34;string\u0026#34;, \u0026#34;git_commit\u0026#34;, \u0026#34;${commit}\u0026#34;) } debug { // To avoid rebuilding  buildConfigField(\u0026#34;String\u0026#34;, \u0026#34;GIT_COMMIT\u0026#34;, \u0026#34;\\\u0026#34;_\\\u0026#34;\u0026#34;) resValue(\u0026#34;string\u0026#34;, \u0026#34;git_commit\u0026#34;, \u0026#34;_\u0026#34;) } } } BuildConfig and R classes are used to compile the code. Any changes harm incremental compilation and build caching. This is a known problem: unstable task inputs.\nTo mitigate this issue the plugin uses assets to store properties. This approach is less harmful for incremental compilation and build caching.\nGetting started #  1. Apply the plugin in the Android module\u0026rsquo;s build script #  plugins { id(\u0026#34;com.avito.android.build-properties\u0026#34;) } In the settings.gradle:\npluginManagement { repositories { maven { name = \u0026#34;Avito bintray\u0026#34; url = \u0026#34;https://dl.bintray.com/avito/maven\u0026#34; } } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } } avitoToolsVersion could be exact version, or property in project\u0026rsquo;s gradle.properties.\nThe latest version could be found on project\u0026rsquo;s release page.\n2. Define properties in a build script #  Kotlin build.gradle.kts\nbuildProperties { buildProperty(\u0026#34;GIT_COMMIT\u0026#34;, commit) } Groovy build.gradle\nbuildProperties { buildProperty(\u0026#34;GIT_COMMIT\u0026#34;, commit) }  3. Add auto-generated file to the .gitignore config #  Content of this file depends on the build. It\u0026rsquo;s no use to store it in VCS.\nbuild-info.properties 4. Read properties in the code #  val properties = Properties() context.assets.open(\u0026#34;build-info.properties\u0026#34;).use { properties.load(it) } val gitCommit = properties.getProperty(\u0026#34;GIT_COMMIT\u0026#34;) "});index.add({'id':13,'href':'/avito-android/docs/projects/buildtrace/','title':"Build trace Gradle plugin",'section':"Docs",'content':"Build trace Gradle plugin #  This plugin is a primitive analog of Gradle build scan. Use it if you can\u0026rsquo;t use a build scan for any reason.\nThis plugin collects tasks execution time in a trace event format.\nGetting started #  Apply the plugin in the root build.gradle file:\nplugins { id(\u0026#34;com.avito.android.build-trace\u0026#34;) } In the settings.gradle:\npluginManagement { repositories { maven { name = \u0026#34;Avito bintray\u0026#34; url = \u0026#34;https://dl.bintray.com/avito/maven\u0026#34; } } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } } avitoToolsVersion could be exact version, or property in project\u0026rsquo;s gradle.properties.\nThe latest version could be found on project\u0026rsquo;s release page.\nRun a build with --profile argument. You will get a message in a log:\nBuild trace: \u0026lt;path to the project\u0026gt;/outputs/trace/build.trace Open the file in chrome://tracing.\nKnown issues #   Tasks\u0026rsquo; completion time is long after a real time (#8630). In a trace it looks like a task is completed right after the another from the same module.  "});index.add({'id':14,'href':'/avito-android/docs/assemble/buildtypes/','title':"Build Types",'section':"Docs",'content':"Типы сборок #  Различаются по предназначению:\n debug - существует для максимально быстрой сборки, чтобы получить максимально быстрый фидбек на изменения в коде staging - для ручного тестирования, сборка проходит медленнее за счет минимизации, но без нее не получится отловить определенный тип багов stagingAutoTest - для авто тестирования, позволяет в тестах дополнительно проверять результат работы r8, а также подключает release source set release - для заливки в магазин      Релизная подпись Минимизация Обфускация Avito Settings Charles proxy SourceSet     debug нет нет нет да да debug   staging нет да нет да да debug   stagingAutoTest нет да нет нет ? release   release да да да нет нет release    Релизная подпись #  Подпись может влиять на настройки разных 3rd party API. Например карты google привязаны к определенной подписи, и без нее могут не показываться вовсе, если также не зарегистрирован API карт на debug ключ.\nПримеры других зависимостей: рекламные SDK, социальные сети.\nМинимизация #  Используется, чтобы уменьшить размер архива с приложением, выпилив оттуда неиспользуемый код. Правила по которым определяется что есть используемый код могут быть ошибочны, так что тестировать следует приложение после минимизации\nКак запустить автотесты на сборке с минимизацией\nОбфускация #  Используется, чтобы запутать взломщиков, в общем случае не должно влиять на корректность кода.\nAvito Settings #  Дополнительное приложение с набором настроек для помощи в ручном тестировании\nCharles Proxy #  Прокси для помощи в тестировании приложения. Статья в CF (internal)\n"});index.add({'id':15,'href':'/avito-android/docs/assemble/buildmetrics/','title':"BuildMetrics",'section':"Docs",'content':"Метрики сборки #  This page contains Avito specific details  Собираем с каждой сборки:\n Время сборки Время конфигурации проекта Эффективность кеширования  Собираем каждую метрику со следующими атрибутами:\n Успешная\\упавшая сборка Окружение: локальная сборка или CI Пользователь (для локальных сборок) Имя хоста (для сборок в CI)  Часть метрик доступна с большей детализацией:\n Аргументы запуска - какую задачу запускали Модуль  Dashboards (internal) #   Время сборки  Общее время сборки Время сборки в разрезе пользователей и задач Бенчмарки Нестандартные настройки проекта   Статистика по задачам Время конфигурации Эффективность кеширования Общая статистика по сборкам  Реализация #  Собираем плагином com.avito.android.build-metrics (build-metrics).\n"});index.add({'id':16,'href':'/avito-android/docs/tech_radar/buildsrc/','title':"buildSrc in Gradle",'section':"Docs",'content':"buildSrc in Gradle #  Quadrant: tools\nStatus (ring): hold\nIt\u0026rsquo;s a default and convenient way for organizing custom plugins and tasks: Gradle - build sources.\nPros #  No binary versions and releases. It works as implicitly included build.\nCons #  Slows project synchronization in IDE #  At Avito, we had 6% of Kotlin code in buildSrc but it cost us about 40% of the time even with all possible optimizations.\nLack of support in IDEA #  Workaround: work with buildSrc as a standalone project.\nStruggle for reusing Gradle and Kotlin daemons #  As a result you waste an extra RAM.\nExample for Gradle daemon: gradle/buildSrc#checkSameDaemonArgs\nSlows configuration time #  Workaround:\n Use remote build cache and keep track a hit rate Exclude compilation of tests in buildSrc in local builds Run tests in buildSrc only in CI  Can\u0026rsquo;t reuse a module from buildSrc #  Technically, you can point directly to a jar from any buildSrc module. This way has limitations:\n IDE knows nothing about it and shows \u0026ldquo;Unsupported module\u0026rdquo; warning Requires buildSrc recompilation after changes It\u0026rsquo;s hard to support transitive dependencies  Harmful for compile avoidance #  Compiled classes from buildSrc will be added to a build script classpath. It can cause extra cache misses and recompilation after changes.\nRecommendations #  Certainly it\u0026rsquo;s a better place for custom plugins, tasks, logic than build-scripts. If you have loads of code or heavy integration tests in plugins, consider moving them to a standalone project.\n"});index.add({'id':17,'href':'/avito-android/docs/projects/cisteps/','title':"CI steps plugin",'section':"Docs",'content':"CI steps plugin #  Plugin wasn\u0026rsquo;t tested outside Avito yet, so expect difficulties, or even blockers. However, if you interested, please contact us!  Plugin creates chains of tasks for CI, encapsulating it under single gradle task.\nGetting started #  Apply the plugin in the app\u0026rsquo;s build.gradle file:\nplugins { id(\u0026#34;com.avito.android.cd\u0026#34;) } The plugin can be applied to a root project or any module.\nIn the settings.gradle:\npluginManagement { repositories { maven { name = \u0026#34;Avito bintray\u0026#34; url = \u0026#34;https://dl.bintray.com/avito/maven\u0026#34; } } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } } avitoToolsVersion could be exact version, or property in project\u0026rsquo;s gradle.properties.\nThe latest version could be found on project\u0026rsquo;s release page.\nBuilds #  First of all, name your chain:\nKotlin builds { register(\u0026#34;myChain\u0026#34;) { //optional description for generated task  taskDescription.set(\u0026#34;This chain does something useful\u0026#34;) } } Groovy builds { myChain { //optional description for generated task  taskDescription.set(\u0026#34;This chain does something useful\u0026#34;) } }  Avito example chains #   localCheck - compilation checks for local run prCheck - as fast as possible checks for Pull Request. It must conform CI agreement fullCheck - as full as possible checks to be run after merges, non-blocking, could be slow release - chain to release our app  Steps #  Step is a declaration to run some logic. It works inside a chain:\nKotlin build { register(\u0026#34;prCheck\u0026#34;) { // \u0026lt;--- chain  unitTests {} // \u0026lt;--- step  uiTests {} lint {} //optional description for generated task  taskDescription.set(\u0026#34;This chain does something useful\u0026#34;) } } Groovy build { fastCheck { // \u0026lt;--- chain  unitTests {} // \u0026lt;--- step  uiTests {} lint {} //optional description for generated task  taskDescription.set(\u0026#34;This chain does something useful\u0026#34;) } }  Now when you invoke ./gradlew fastCheck gradle will run unitTests, uiTests and lint of corresponding project\nBuilt-in steps #  UI tests #  Runs instrumentation tests.\nKotlin uiTests { configurations(\u0026#34;configurationName\u0026#34;) // list of instrumentation configuration to depends on  sendStatistics = false // by default  suppressFailures = false // by default  useImpactAnalysis = true // by default  suppressFlaky = false // by default. [игнорирование падений FlakyTest](https://avito-tech.github.io/avito-android/docs/test/flakyannotation/). } Groovy uiTests { configurations = [\u0026#34;configurationName\u0026#34;] // list of instrumentation configuration to depends on  sendStatistics = false // by default  suppressFailures = false // by default  useImpactAnalysis = true // by default  suppressFlaky = false // by default. [игнорирование падений FlakyTest](https://avito-tech.github.io/avito-android/docs/test/flakyannotation/). }  Android lint #  Run Android lint tasks.\nKotlin lint {} Groovy lint {}  Compile UI tests #  Compile instrumentation tests. It is helpful in local development.\nKotlin compileUiTests {} Groovy compileUiTests {}  Unit tests #  Run unit tests.\nKotlin unitTests {} Groovy unitTests {}  Upload to QApps #  This step contains Avito specific details  Upload artifacts to QApps (internal system)\nKotlin artifacts { apk(\u0026#34;debugApk\u0026#34;, ...) } uploadToQapps { artifacts = setOf(\u0026#34;debugApk\u0026#34;) } Groovy artifacts { apk(\u0026#34;debugApk\u0026#34;, ...) } uploadToQapps { artifacts = [\u0026#34;debugApk\u0026#34;] }  Upload to Artifactory #  Upload artifacts to Artifactory.\nKotlin artifacts { file(\u0026#34;myReport\u0026#34;, \u0026#34;${project.buildDir}/reports/my_report.json\u0026#34;) } uploadToArtifactory { artifacts = setOf(\u0026#34;myReport\u0026#34;) } Groovy artifacts { file(\u0026#34;myReport\u0026#34;, \u0026#34;${project.buildDir}/reports/my_report.json\u0026#34;) } uploadToArtifactory { artifacts = [\u0026#34;myReport\u0026#34;] }  Upload to Prosector #  This step contains Avito specific details  Upload artifacts to Prosector (internal).\nKotlin artifacts { apk(\u0026#34;debugApk\u0026#34;, ...) } uploadToProsector { artifacts = setOf(\u0026#34;debugApk\u0026#34;) } Groovy artifacts { apk(\u0026#34;debugApk\u0026#34;, ...) } uploadToProsector { artifacts = [\u0026#34;debugApk\u0026#34;] }  Upload build results #  This step contains Avito specific details  Upload all build results to a deploy service.\nKotlin uploadBuildResult { uiTestConfiguration = \u0026#34;regression\u0026#34; // instrumentation configuration } Groovy uploadBuildResult { uiTestConfiguration = \u0026#34;regression\u0026#34; // instrumentation configuration }  Deploy to Google Play #  This step contains Avito specific details  Deploy to Google play.\nKotlin deploy {} Groovy deploy {}  Mark report as source of truth for TMS #  See Test case in code\nConfiguration checks #  This check contains Avito specific details  Checks a repository configuration. See :build-script-test for details.\nKotlin configuration {} Groovy configuration {}  Using impact analysis in step #  Step can use Impact analysis. It is enabled by default.\nKotlin fastCheck { uiTests { } } Groovy fastCheck { uiTests { } }  Suppressing errors in step #  In different scenarios steps could fail whole build, some can be configured not to.\nKotlin fastCheck { uiTests { suppressFailures = false } } release { uiTests { suppressFailures = true } } Groovy fastCheck { uiTests { suppressFailures = false } } release { uiTests { suppressFailures = true } }  Collecting artifacts #  Artifacts that planned to be used(uploaded somewhere) must be registered:\nKotlin artifacts { file(\u0026#34;lintReport\u0026#34;, \u0026#34;${project.buildDir}/reports/lint-results-release.html\u0026#34;) } Groovy artifacts { file(\u0026#34;lintReport\u0026#34;, \u0026#34;${project.buildDir}/reports/lint-results-release.html\u0026#34;) }  There are different types of artifacts:\n apk - gets apk by buildType and checks packageName and signature bundle - gets bundle by buildType and checks packageName and signature mapping - gets r8 mapping by buildType and checks availability file - gets any file by path and checks availability  Kotlin import com.avito.cd.BuildVariant.RELEASE val releaseSha1 = \u0026#34;my sha\u0026#34; // it\u0026#39;s public info, so safe to share  artifacts { apk(\u0026#34;releaseApk\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, \u0026#34;${project.buildDir}/outputs/apk/release/avito.apk\u0026#34;) { signature = releaseSha1 } bundle(\u0026#34;releaseBundle\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, \u0026#34;${project.buildDir}/outputs/bundle/release/avito.aab\u0026#34;) { signature = releaseSha1 } mapping(\u0026#34;releaseMapping\u0026#34;, RELEASE, \u0026#34;${project.buildDir}/outputs/mapping/release/mapping.txt\u0026#34;) file(\u0026#34;featureTogglesJson\u0026#34;, \u0026#34;${project.buildDir}/reports/feature_toggles.json\u0026#34;) } Groovy def releaseSha1 = \u0026#34;my sha\u0026#34; // it\u0026#39;s public info, so safe to share  artifacts { apk(\u0026#34;releaseApk\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, \u0026#34;${project.buildDir}/outputs/apk/release/avito.apk\u0026#34;) { signature = releaseSha1 } bundle(\u0026#34;releaseBundle\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, \u0026#34;${project.buildDir}/outputs/bundle/release/avito.aab\u0026#34;) { signature = releaseSha1 } mapping(\u0026#34;releaseMapping\u0026#34;, RELEASE, \u0026#34;${project.buildDir}/outputs/mapping/release/mapping.txt\u0026#34;) file(\u0026#34;featureTogglesJson\u0026#34;, \u0026#34;${project.buildDir}/reports/feature_toggles.json\u0026#34;) }  The first argument is a key for upload steps.\nWriting a custom step #  Inherit from BuildStep, check available implementations as examples\n"});index.add({'id':18,'href':'/avito-android/docs/ci/civalues/','title':"CI Values",'section':"Docs",'content':"Требования к Continuous Integration #  Польза #  Проверки помогают не допускать ошибки\nСкорость получения фидбека #  Ожидаем что билд идет не больше 30 минут\nПонятность фидбека #  При падении однозначно понимаем в чем проблема\nНет лишнего шума (бесполезных warning\u0026rsquo;ов на которые неизвестно как реагировать)\nДетерминизм #  Запуски на том же коммите должны приводить к одинаковым результатам\n"});index.add({'id':19,'href':'/avito-android/docs/contributing/codereview/','title':"Code review",'section':"Docs",'content':"Code review / Pull request #  Инспекция кода проводится для всех изменений в репозитории. Она проводится при отправке изменений в любую ветку, кроме feature. Просмотр и одобрение кода доступно всем разработчикам, но на отправку кода в develop, master накладываются ограничения.\nЦели инспекции кода #  Улучшение качества кода и продукта:\n Поиск и устранение ошибок и уязвимостей Оценка поддерживаемости, удобства использования Проверка на соответствие принятым стандартам (того, что невозможно или нецелесообразно автоматизировать)  Для команды:\n Совместное владение кодом, уменьшение фактора автобуса Обучение и наставничество Развитие культуры команды  Best practices #  Избегаем крупных PR #  Большие изменения делают неэффективной инспекцию кода, порождают конфликты. Применяем следующие подходы:\n Декомпозируем задачу и делаем в отдельных ветках, сливая более мелкими частями При возможности используем feature toggle, чтобы не держать долгоживущие ветки Изменения общих классов стараемся заранее выносить в отдельный PR. Например, начал делать задачу и видишь что нужно сильно менять модель данных. Лучше сделать это отдельным рефакторингом до реализации бизнес-функциональности.  Основная идея: develop играет роль CI при реализации задач. Лучше уменьшать интгерационные проблемы, сливать чаще, меньшими частями, работать на упреждение. Принимаем определенные риски, но размываем их по мелким задачам, так с ними проще бороться.\nПравило бойскаута или оппортунистический рефакторинг #  Opportunistic refactoring (Martin Fowler).\nПри необходимости рефакторинга стараемся заложить его в оценку бизнес-задачи, не откладывать на потом. Если совсем небольшой, то можно прямо в основной задаче, но желательно отдельным коммитом.\nНе переходи на личности. Обсуждай код, но не автора #  Это правило трудно переоценить, но оно лишь необходимое, но не достаточное условие. Даже в этом случае критика может быть принята в отношении человека. Нужно уметь критиковать, доносить предложения.\nБез оскорблений и ругательств #  У всех разное чувство юмора и поэтому даже безобидные на первый взгляд выражения могут быть восприняты оскорбительно.\nБез требовательных и вызывающих выражений #  Если смысл комментария можно свести к фразе \u0026ldquo;ты неправ\u0026rdquo;, например:\n \u0026ldquo;Так не сработает\u0026rdquo; \u0026ldquo;Совершенно неправильно\u0026rdquo; \u0026ldquo;Почему ты просто не …?\u0026rdquo;  Это неконструктивно, как минимум. Необходимо объяснить суть претензии, предложить решение.\nНе будь пассивно-агрессивным #  Не надо демонстрировать раздражение, избегай неприятных фраз и претензий:\n \u0026ldquo;Ещё раз повторяю: здесь нужно…\u0026rdquo; \u0026ldquo;Как я уже говорил…\u0026rdquo; \u0026ldquo;Как скажешь, делай как хочешь\u0026rdquo; \u0026ldquo;Если кому-нибудь вообще интересно, …\u0026rdquo;  Не нарушай правило «Никаких сюрпризов» #  Избегаем неожиданностей. Требования должны быть явные и зафиксированы в соглашениях.\nНе будь непрошенным советчиком #  Целью рецензирования не должно стать принуждение написать код так, как бы тебе хотелось. Уважай право автора на собственные решения, если они обоснованы. Главное — качественный, удобный в сопровождении код. Слишком много обсуждений не по существу скорее запутают, отвлекут от важного.\nУчитывай свои цели #  Всегда принимай во внимание то, чего хочешь достичь комментарием? Указать на конкретную проблему в коде? Помочь или подсказать? Или может быть только показать какой ты умный и подтвердить свою правоту? Иногда лучше держать своё мнение при себе.\nХвали хороший код #  Положительные комментарии хороших решений помогают лучше реагировать на критику, снимают напряженность в общении. Только без наигранности и слащавости, комментировать решения по сути. Также можно комментировать логику, свое понимание изменений (монолог на ходу). Это дает дополнительный шанс проверить корректность и понимание работы.\nИзбегай обвинений #  Лучше спрашивать, а не обвинять и делать громкие заявления. Это улучшает восприятие, направляет в сторону решения, а не рефлекторной обороны от обвинений. Будь осторожен с вопросами \u0026ldquo;Почему?\u0026rdquo;. Они могут звучать обвинительно.\n👎\n «Здесь ты не соблюдал стандарты» «А — неправильно, надо использовать В» «Запутанный код» «Ты не сделал X» «Почему ты просто не …?»   👍\n «Какие причины выбора такого решения?» «Зачем ты использовал A вместо B?» «Эта часть мне непонятна. Можешь объяснить?» «Я не нашёл, где сделано X» «Чем ты руководствовался, когда …?»    Объясняй причину #  Поясняй причину, что конкретно улучшит предлагаемое изменение.\nWorkflow #  Создание PR #   PR создается после реализации функциональных требований. Для декомпозиции и уменьшения PR используем отдельные [под]задачи. Допустимо создание промежуточных PR для небольших рефакторингов, но декомпозиция работ должна быть осмысленная. Это не должно приводить к грязному develop. Все это обязательно комментируем. Иначе такой PR формально можно отклонить как недоделанный. Рекомендуется превентивно прокомментировать неочевидные места, пояснить решения, чтобы рецензенты лучше вникли в суть задачи и проверили более качественно. При необходимости, в описании PR можно пометить (в свободной форме) возможность слияния. По умолчанию это может делать только создатель.  Рецензенты (reviewers) #  Любой PR необходимо смотреть и комментировать всем членам команды. Это важный способ обмена знаниями. По умолчанию, при создании PR, список рецензентов пустой. Но можно указать желаемых участников.\nПеред началом просмотра #  Добавить себя в список рецензентов. Так обозначаем, что начали рецензирование. При невозможности закончить, необходимо удалить себя из списка рецензентов.\nВ процессе #  Что проверяем?\n  Соответствие принятым стандартам и соглашениям\n  PR содержит изменения только по заявленной в задаче функциональности\n  По возможности, сразу создаем задачи с конкретными предложениями. Это удобное средство, упрощающее отслеживание исправлений. Нельзя слить PR, если в нем есть незавершенные задачи.\n  Комментарии, не требующие никакой ответной реакции, являются исключением и помечаются специально. Для них пишем \u0026ldquo;FYI \u0026hellip;\u0026rdquo;\n  Неактуальные комментарии можно не удалять, а оставлять намеренно в угоду сохранения истории обсуждения. Подобные комментарии могут быть маркером неочевидных решений, плохо читаемого кода и т.п.\n  По окончании #  Явно отражаем бинарный результат:\n Approve - можно сливать, полностью устраивает в таком виде. Needs Work - требуются доработки (любые).  Этот статус не надо рассматривать как оценку качества.\nОн лишь констатирует факт - сливать в таком виде еще нельзя.\nРекомендуется ставить при наличии любых блокеров (конфликты, открытые задачи, \u0026hellip;). Мотивация: если в PR отмечено что можно сливать и все поставят апрувы при наличии открытых задач, то после закрытия задач можно случайно смержить еще до пуша исправлений. Поэтому апрув должен быть явный, не впрок.\nDecline неудобен тем, что теряется история обсуждений. Используем только если хотим полностью отменить PR.\nАвтор #  По каждому комментарию дает обратную связь:\n Исправить код, если все очевидно. Краткое описание изменений удобно делать в задачах. По каждому исправлению необходимо дать ответ, что и как именно исправлено (рекомендуется выразить это задачей). Если что-то сделано намеренно, то необходимо пояснить причины. На открытые вопросы необходимо дать ответы.  При наличии одобрения от всех рецензентов сливает изменения.\nПроблемные сценарии #  Случайное бекпортирование при слиянии в несколько веток - создавать PR последовательно:\nСначала сливаем в \u0026ldquo;более стабильную” (release и т.п.) ветку, исправляем замечания и т.п.\nПотом сливаем в \u0026ldquo;более новую\u0026rdquo; (develop) ветку, уменьшая риск случайного бэкпортирования.\nPR в более стабильные ветки необходимо создавать сразу, не откладывать на потом. Конфликты лучше решать сразу, не накапливать.\nДругое #  В описании PR, относящихся к задачам по обновлению версии библиотек, необходимо указывать What\u0026rsquo;s new для новой версии библиотеки.\nМотивация: предоставить рецензентам весь контекст, чтобы обсуждать более предметно.\nМатериалы по теме #   Как подписаться на изменения в модулях? Code Ownership Plugin (internal) Рекомендации Google: How to do a code review  "});index.add({'id':20,'href':'/avito-android/docs/contributing/codestyle/','title':"Code style",'section':"Docs",'content':"Code Style #  Автоматизация #  Editor config #  За настройку code style отвечает editor config. А точнее плагин для IDE.\nНужно убедиться, что плагин установлен и включен (Preferences \u0026gt; Plugins \u0026gt; Installed \u0026gt; search: EditorConfig)\nПосле этого все настройки авто-формата должны применяться по порядку:\n EditorConfig настройка на уровне папки EditorConfig настройка на уровне проекта Личная настройка в IDE (если не определены настройки выше)  Правила определены в .editorconfig в корне проекта. И переопределены в папках где значения по-умолчанию не устраивают (например ci/docker/android-builder/.editorconfig).\n.idea/codeStyles (legacy) #  Отказались от использования xml, которые сохраняет IDE. Разные версии Android Studio автоматически вносят изменения в файл настроек и это невозможно отключить. Как итог, получали нежелательные и конфликтующие изменения. Это отвлекает и мешает использовать разные версии IDE.\nЕсли автоматика сломалась #  Порой по разным причинам автоматические настройки code style слетают, это больное место в Android Studio. Причиной может быть к примеру обновление версии.\nВыставить настройки близкие к автоматическим можно так:\n Preferences -\u0026gt; Editor -\u0026gt; Code Style установить Hard wrap - 120 Preferences -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Kotlin  Set From -\u0026gt; Predefined Style -\u0026gt; Kotlin Style Guide Imports -\u0026gt; Use single name import в обоих опциях Imports -\u0026gt; Packages to Use Imports with * - удалить все    Проверки в CI #  В данный момент соответствия code style проверяются вручную на Code Review (Задача на автоматизацию - MBS-6991 (internal)).\nCode guidelines #  Именование #  Packages #   Не должен содержать заглавные символы, чтобы избегать конфликтов с интерфейсами и классами. Допускается использования символа _  С точки зрения бизнес-модулей стараемся делать плоскую структуру пакетов, не привязываясь к навигации. Примеры:\n categories вместо category/list  Variables #   Детальность названия должна соответствовать области видимости. Не экономим на буквах в ущерб читаемости. Сокращения допустимы для общепринятых терминов.  val ctx: Context val context: Context  Имя должно отражать смысл. Избегаем излишних знаний про реализацию и тип данных.  val bundle: Bundle val state: Bundle Kotlin #  Используем Kotlin official style guide\nFile structure #  Extension функции и свойства рекомендуется располагать в файле с названием расширяемого класса во множественном числе. Исключение: Если extension относится к типизированной коллекции, то он должен располагаться в файле с названием типа а не коллекции. Мотивация: однозначный поиск, не нужно думать куда это положили. Пример:\nViews.kt: fun View.hide() = ... Dimensions.kt: fun List\u0026lt;Dimension\u0026gt;.findByRatio() = ... Lists.kt: fun List\u0026lt;T\u0026gt;.second() = ... Публичные классы и файлы #  В файле должно быть не более одного публичного класса\\интерфейса\\аннотации... Исключение делаем для вырожденных реализаций интерфейса, которым нельзя придумать осмысленного именования и из-за этого не может быть нескольких имплементаций (...Impl и т.п.).\nМотивация: нужны простые и однозначные правила для навигации, иначе имя файла становится бесполезным. Если каждый будет располагать согласно предпочтениям, то это может привести к бесконечному рефакторингу и лишним спорам.\nКонстанты #  Константные значения на уровне файла называем в нотации ALL_UPPER_CASE. Значения для строковых констант по возможности пишем в snake_case. Не мусорим в пространстве имен: обязательно используем минимально возможную видимость (private если используется только в этом файле, internal если используется только в пределах модуля). Примитивные значения и строки дополнительно помечаем модификатором const\nprivate const val KEY_MESSAGE = “key_fragment_message\u0026#34; internal const val INVALID_POSTIION = Int.MIN_VALUE Аргументы функций Неочевидные аргументы необходимо именовать при вызове.\nPlatform types Избегаем платформенные типы. При взаимодействии с Java кодом указывать типы явно, чтобы избежать потенциальных ошибок.\nval fooId = arguments.getString(KEY_FOO_ID) // --\u0026gt; String! val fooId: String? = arguments.getString(KEY_FOO_ID) // --\u0026gt; String? Reified type parameters При наличии альтернативы предпочтительно вывести тип автоматически, средствами языка, чтобы избежать возможных ошибок при приведении типа:\nval location = readParcelable(Profile::class.java.classLoader) val location = readParcelable() Комментарии #  Комментирование кода Комментариев избегаем. Используем только для пояснения неочевидных моментов, но максимально пытаемся выразить смысл кодом. Временное комментирование кода допускается в feature ветках. От неиспользуемого кода избавляемся и не пытаемся использовать комментарии вместо VCS. Мотивация: устаревание комментариев, они начинают врать, а это хуже чем их отсутствие.\nПри необходимости временно закомментировать участок кода предпочтительно использовать // комментарии вместо /* */. Мотивация: проще редактировать, т.к. у каждой строки нет \u0026ldquo;контекста\u0026rdquo;. Например, проблемно раскомментировать несколько строк внутри /* */ комментария.\nКомментирование решений При необходимости пояснить решение избегаем комментарии. Необходимо выражать смысл кодом - в названиях переменных, методов и т.п. Пример - дублирование if, который не поясняет смысл проверки. Мотивация: код должен быть самодокументируемым. Комментарии легко устаревают, становятся ложными и могут даже навредить, введя в заблуждение (см. Clean Code)\nTODO комментарии Допускаются комментарии вида // TODO comment Обязательно наличие пояснения. Rule of thumb: из комментария сразу должна быть понятна суть. Иначе этот комментарий не нужен.\nDeprecations #  Когда в коде появляется новый класс или метод, который дублирует функции уже существующего, то желательно удалять старый. Если такой возможности нет, то помечаем старый класс или метод аннотацией @Deprecated, но обязательно с комментарием и указателем на новый. Для kotlin аннотации @Deprecated обязательными для заполнения параметрами являются message и replaceWith.\nImports #  Fully qualify imports This is bad: import foo.* This is good: import foo.Bar Мотивация: используемые зависимости очевидны, меньше конфликтов. Читаемость и поддерживаемость важнее. Источник\nOrdering #  Порядок методов и полей Публичное преимущественно располагаем в начале класса, приватное и с большей детализацией - ниже. Метод должен быть при возможности сразу после места его использования. Мотивация: основная цель - обеспечить хорошую читаемость кода. В идеале код должен читаться как рассказ. Для этого надо минимизировать навигацию при чтении.\nXML #  Размеры, отступы и кегли шрифтов выносим в dimens.xml, если они повторяются или имеют разные значения для разных конфигураций экранов. Даем осмысленные имена в snake_case. Пример: \u0026lt;dimen name=\u0026quot;list_card_vertical_padding\u0026quot;\u0026gt;4dp\u0026lt;/dimen\u0026gt; Мотивация: быстрая адаптация верстки к различным экранам.\nLayout называем придерживаясь правила \u0026lt;where\u0026gt;[_\u0026lt;description\u0026gt;].xml\n \u0026lt;where\u0026gt; описывает экран или его логическую часть. \u0026lt;description\u0026gt; - необязательное описание. Может включать в себя маркеры типа: activity, fragment и тп.  Пример: profile_editor.xml, offer_common_part.xml, balance.xml, order_item.xml Мотивация: быстрая и удобная навигация в папках с ресурсами, благодаря переносу смысловой нагрузки в начало. order[_activity].xml вместо activity_order.xml\nС помощью FOLDING_PLUGIN, можно добиться групирования по виртуальным папкам.\nview id именуем в snake_case. Пример: android:id=\u0026quot;@+id/category_title\u0026quot;.\nСтили называем в PascalCase. Пример: \u0026lt;style name=\u0026quot;AvitoButton.Transparent\u0026quot;\u0026gt;.\n"});index.add({'id':21,'href':'/avito-android/docs/contacts/','title':"Contacts",'section':"Docs",'content':"Contacts #  Public channels #  Telegram chat (Russian)\nInternal channels #  This section contains Avito specific details  Slack #   #android-dev - single slack channel for any Android related stuff #android-autotesting - all about testing #speed  If your problem is urgent or you cannot solve it for a long time just mention @android-speed-team in any channel from above.\nIssues #  We track our issues in MBS project.\n"});index.add({'id':22,'href':'/avito-android/docs/ci/customgradleplugins/','title':"Custom Gradle Plugins",'section':"Docs",'content':"Custom Gradle plugins #  Вся логика CI расположена в in-house Gradle плагинах. Для тестирования корневого проекта смотри модуль build-script-test.\nHow to start #  Начни с официальных туториалов, они сэкономят время:\n Gradle plugin development tutorials\nДля нас не актуальна только публикация плагинов. Custom tasks  Если что-то не понятно, здесь тебе помогут:\n #gradle (internal) gradle-community.slack.com  Работа с плагинами в IDE #   Предпочтительно использовать IntelliJ IDEA Import project Согласись использовать Gradle wrapper Settings \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle \u0026gt; Runner  Delegate IDE build/run actions to Gradle (check) Run tests using : Gradle Test Runner    Теперь можно запускать тесты по иконкам run\nKnown issues:\n Имя теста (DynamicTest.displayName) некорректно отображается в IDE: #5975  Debugging #  Для тестов работает из IDE.\nДля отладки плагина:\n Добавь в IDE конфигурацию Remote для запуска, как для обычного java проекта. Запускай Gradle из корня репозитория с параметрами -Dorg.gradle.debug=true --no-daemon  Debugger работает не только в нашем коде, остановиться можно и в AGP или Gradle.\nTesting Gradle plugins #  Isolating business-logic for unit-tests #  You can isolate most of the logic from Gradle. Thus, it can be covered easily by unit-tests.\nabstract class FeatureTask @Inject constructor( private val workerExecutor: WorkerExecutor ) : DefaultTask() { @TaskAction fun action() { val apiConfig = ... // get from the project  workerExecutor.noIsolation().submit(FeatureWorkerAction::class.java) { parameters -\u0026gt; parameters.getIntegrationApiConfig().set(apiConfig) } } } // This wrapper is needed only for Worker API // It can be started in another process. Thus, it has to prepare dependencies for the real work.  abstract class FeatureWorkerAction : WorkAction\u0026lt;Parameters\u0026gt; { interface Parameters : WorkParameters { fun getIntegrationApiConfig(): Property\u0026lt;IntegrationApiConfig\u0026gt; } override fun execute() { val api = IntegrationApiConfig.Impl(parameters.getIntegrationApiConfig().get()) val action = FeatureAction( integrationApi = api ) action.execute() } } // This class is responsible for the real work. // The less it knows about Gradle, the better.  class FeatureAction( private val integrationApi: IntegrationApi ) { fun execute() { // Do the real work here  } } // Now you can use simple mocks to test the action. @Test fun test() { val integrationApi = mock\u0026lt;IntegrationApi\u0026gt;() whenever(integrationApi.foo).thenReturn(bar()) val action = FeatureAction(integrationApi) \u0026lt;-- No Gradle abstractions here action.execute() assertThat(...) } Integration tests #  For simple cases you can create dummy instance of Project by ProjectBuilder\nval project = ProjectBuilder.builder().build() val task = project.tasks.register\u0026lt;TestTask\u0026gt;(\u0026#34;testTask\u0026#34;) {} task.get().doStuff() When you need to run a real build, use Gradle Test Kit.\nSee ready utilities in :test-project module.\nЗапуск тестов из консоли #  ./gradlew test\nЧтобы не останавливать прогон тестов на первом падении добавь --continue\nДля запуска отдельного теста, класса или пакета работает фильтр: --tests package.class.method, но нужно запускать тесты для отдельного модуля, иначе фильтр упадет не найдя нужных тестов по фильтру в первом попавшемся модуле.\nBest practices #  Fail-fast contract #  Each plugin should check preconditions as early as possible. If some parameter is missing or has invalid value, the plugin should fail and explain the reason.\nFeature toggles #  The plugin may break and blocks the work of other developers. Making the plugin unpluggable gives you time for a fix.\nopen class MyPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(project: Project) { // In each property use prefix `avito.\u0026lt;plugin\u0026gt;`  // It makes it easy to find it in the future  if (!project.getBooleanProperty(\u0026#34;avito.my_plugin.enabled\u0026#34;, default = false)) { project.logger.lifecycle(\u0026#34;My plugin is disabled\u0026#34;) return } } } Logging #  Do not use System.out or System.err to log something from your plugin. It is not customizable and do not allow you to write logs to a file or disable them at all. Consider using com.avito.utils.logging.CILogger. It is serializable so it can be passed through org.gradle.workers.WorkerConfiguration.setParams and it is able to direct logs to a file.\nThere are convenient extensions allowing you to get instance of CILogger:\nval Task.ciLogger: CILogger get() = ... val Project.ciLogger: CILogger get() = ... Директория ci #  Там храним всю интеграцию с CI.\nЧасто нужно править плагин совместно с ./ci/\nЧтобы работать одновременно со всем этим кодом, к уже открытому проекту добавь модуль ci: File \u0026gt; New \u0026gt; Module from existing sources \u0026gt; путь до папки ci \u0026gt; ok \u0026gt; ok\nИнтеграция плагина в CI #  CI Steps Plugin\nДополнительные материалы #   Интеграция с AGP 4+  "});index.add({'id':23,'href':'/avito-android/docs/assemble/dependencies/','title':"Dependencies",'section':"Docs",'content':"Dependencies #  Artifactory #  Free version of Artifactory used in Avito Android development to be a proxy for every 3-rd party dependency.\nDependency resolving performance and artifacts availability is crucial for our CI/CD pipelines and developers local work.\n[Internal Avito instance]\nAdding new proxy repositories #  If you have new dependency, which is not listed in available proxies, please contact our team.\n"});index.add({'id':24,'href':'/avito-android/docs/architecture/dagger/','title':"Dependency Injection with Dagger",'section':"Docs",'content':"Dagger #  This page contains Avito specific details  Материалы #  Обязательно прочесть #   Документация Тредик на гитхабе с tips \u0026amp; tricks для kotlin  Рекомендую к изучению #   Видео от одного из авторов Dagger Ron Shapiro, о том, как правильно его готовить Немного устаревшая статья про правильное приготовление dagger  ⚠️ Нельзя постигнуть даггер, не смотря какой код он генерирует!  Как правильно работать с Dagger #   Поддерживаемость прежде всего. Граф зависимостей делай маскимально простой и понятный Application Component имеет минимальный скоуп - содержит не более необходимого чилсла зависимостей Если зависимость может быть не глобальной, оне должа быть в скоупе экрана, а не приложения Меньше мокай в instrumentation-тестах  Provides → Binds #  Используй Binds вместо Provides по-возможности всегда\n👍 Dagger генерирует меньше классов и получается более эффективный код.\n👍 Проще писать Module-классы и изменять код, как в конструкторах, так и в Module-классах.\nВ самом простом случае необходимо добавить к объявлению класса @Inject constructor и переделать метод класса на абстрактный, который связывает интерфейс и реализацию:\nБыло:\n@Provides @PerFragment internal fun provideSearchDeepLinkInteractor( api: SearchApi, searchParamsConverter: SearchParamsConverter, schedulersFactory: SchedulersFactory ): SearchDeepLinkInteractor { return SearchDeepLinkInteractorImpl(api, searchParamsConverter, schedulersFactory) } Стало:\n@Binds @PerFragment fun bindsSearchDeepLinkInteractor(interactor: SearchDeepLinkInteractorImpl): SearchDeepLinkInteractor Было:\nclass SearchDeepLinkInteractorImpl( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Стало:\nclass SearchDeepLinkInteractorImpl @Inject constructor( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Когда использовать @Provides #  Когда идет любое конфигурирование/инициализация, например features. Dagger - инструмент DI. Старайтесь минимально заниматься решением задач не связанных с DI через Dagger. Меньше кода в Dagger-модуле - лучше.\n@Provides @PerFragment internal fun providePermissionHelper(features: Features, dialogRouter: DialogRouter): PermissionHelper { val permissionHelper = FragmentPermissionHelper(fragment) return if (features.geoPermissionDialog.value) { LocationPermissionHelperWrapper(permissionHelper, dialogRouter) } else { permissionHelper } } Если нужно мокать методы модуля для тестирования. Мокать binds-методы не имеет смысла - это просто источник информации для процессора Dagger.\nИнстанциирование сторонних классов. Невозможно прописать Inject в конструктор класса, к исходному коду которого нет доступа.\n@Provides @JvmStatic internal fun provideAdapterPresenter(provider: ItemBinder): AdapterPresenter { return SimpleAdapterPresenter(provider, provider) } Static providers: object #  При использовании @Provides объявляй класс object.\n👍 В этом случае R8 удалит всю инициализацию и может заинлайнить методы (они будут действительно статическими).\n@Module object Module { @Provides fun provideObject(): Object { return Object() } } 👎 Нельзя мокать модули в тестах, что не часто нужно.\nIntoSet / IntoMap #  Используй IntoSet (IntoMap). Проставь JvmSuppressWildcards, чтобы Dagger понял какого типа вам нужны данные.\n👍 Позволяет в разных модулях собирать необходимые вам объекты в список.\nЧтобы подключить новый класс и он долетел куда нужно достаточно соблюсти интерфейс, и добавить IntoSet (IntoMap) @Binds @IntoSet fun bindCategorySettingsItemBlueprint(blueprint: CategorySettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Binds @IntoSet fun bindLogoWithVersionSettingsItemBlueprint(blueprint: LogoWithVersionSettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Provides @PerActivity internal fun provideItemBinder( blueprints: Set\u0026lt;@JvmSuppressWildcards ItemBlueprint\u0026lt;*, *\u0026gt;\u0026gt; ): ItemBinder { return with(ItemBinder.Builder()) { blueprints.forEach { registerItem(it) } build() } } 👎 В сложной иерархии модулей может потеряться контроль над тем, что прилетает из графа dagger.\n👎 Необходимо использовать квалификтаторы (Named), в случае если интерфейсы клэшатся и нужно сделать два набора данных\nScope overuse #  Не злоупотребляй скоупами без надобности.\nКаждый скоуп, кроме Reusable (Singleton, PerActivity, PerFragment, etc) порождает использование Dagger-класса DoubleCheck, который реализует проверку DoubleCheckLock для гарантий Singleton.\npublic T get() { Object result = instance; if (result == UNINITIALIZED) { synchronized (this) { result = instance; if (result == UNINITIALIZED) { result = provider.get(); instance = reentrantCheck(instance, result); /* Null out the reference to the provider. We are never going to need it again, so we * can make it eligible for GC. */ provider = null; } } } return (T) result; } Reusable scope порождает проверку SingleCheck, которая менее строгая:\npublic T get() { Object local = instance; if (local == UNINITIALIZED) { // provider is volatile and might become null after the check, so retrieve the provider first  Provider\u0026lt;T\u0026gt; providerReference = provider; if (providerReference == null) { // The provider was null, so the instance must already be set  local = instance; } else { local = providerReference.get(); instance = local; // Null out the reference to the provider. We are never going to need it again, so we can  // make it eligible for GC.  provider = null; } } return (T) local; } Component.Builder → Component-Factory #  👍 Ошибка когда при создании компонента забывают вызвать один из методов билдера вылетит во время компиляции а не в рантайме.\nБыло:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Builder interface Builder { fun settingsDependencies(settingsDependencies: SettingsDependencies): Builder fun locationDependencies(locationDependencies: LocationDependencies): Builder @BindsInstance fun state(state: Kundle?): Builder @BindsInstance fun resources(resources: Resources): Builder @BindsInstance fun settingsItemsStream(settingsItemsStream: PublishRelay\u0026lt;String\u0026gt;): Builder fun build(): SettingsComponent } } Стало:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } Лучше именовать параметры при вызове, чтобы не перепутать, если есть аргументы одного типа идущие последовательно:\nDaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) BindInstance → stateless module #  👍 Вы сможете провайдить объект в дерево Dagger не добавляя его в конструктор модуля.\nЭто сделает его статическим, что хорошо. См. пункт 1 про статические провайдеры.\nБыло:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { fun module(module: SettingsModule): Builder fun create(): SettingsComponent } } class SettingsModule(val kundle: Kundle) {...} Стало:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { @BindsInstance fun create(state: Kundle?): Factory } } object : SettingsModule() {...} Хорошее правило:\n✅ Singleton (PerActivity, PerFragment), если важна гарантия единственности\n✅ Reusable - если singleton нужен для оптимизации\n✅ во всех остальных случаях избегайте скоупов Перевод субкомпонентов уровня Application в компоненты #  Проблема #  Subcomponents в сгенерированном коде - это вложенный класс в Component.\nПоэтому использовать subcomponent для фичей\\экранов дорого:\n Ломает compilation avoidance: каждое изменение субкомпонента приводит к перегенерации компонента в avito (самый тяжелый модуль с тестами). Хуже масштабируется: ApplicationComponent распухает, содержит все фичи, растет время его компиляции. Дольше инициализации ApplicationComponent  Решение #   Не использовать subcomponent на уровне Application, выделить отдельные Dagger-компоненты в Gradle-модулях. Внутри компонента на уровне модули использовать субкомпоненты уже не проблема, не аффектит все приложение.  Тогда основной даггер-граф из Application вообще может не перегенерироваться при изменении в Gradle-модулях (бывшие субкомпоненты).\nАлгоритм #   Выявить интерфейсы, которые нужны и будут прилетать из основного (application) дерева Dagger.\nНайти их можно по использованию. Они инжектятся напрямую, либо используются в модулях.\nЕсли сразу непонятно, какие интерфейсы понадобятся, можно сделать пустой интерфейс и заполнять его по мере того, как Dagger будет сообщать о том, что не хватает.  interface SettingsDependencies : ComponentDependencies { } Выделить их в отдельный интерфейс, отнаследовав от ComponentDependencies:\n⚠️ Это самый сложный этап, где Dagger ругается что ему не хватает из основного графа, а вы выписываете недостающее.\nДля часто используемых общих зависимостей выделили CoreComponentDependencies.  interface SettingsDependencies : ComponentDependencies { fun activityIntentFactory(): ActivityIntentFactory fun context(): Context fun startupStorage(): StartupStorage fun deviceIdProvider(): DeviceIdProvider fun schedulersFactory(): SchedulersFactory fun profileInfoStorage(): ProfileInfoStorage fun deviceMetrics(): DeviceMetrics fun debugIntentFactory(): DebugIntentFactory } Eсли используются дополнительные модули (например, SavedLocationInteractorModule), у них могут быть готовые интерфейсы:  interface LocationDependencies : ComponentDependencies { fun locationApi(): LocationApi fun savedLocationStorage(): SavedLocationStorage } Отнаследовать ApplicationComponent от интерфейсов из прошлых шагов:  interface ApplicationComponent : BaseApplicationComponent, LocationDependencies, SettingsDependencies, ... } Добавить в ComponentDependenciesModule маппинг нового ComponentDependencies:  @Binds @IntoMap @ComponentDependenciesKey(SettingsDependencies::class) abstract fun provideSettingsDependencies(component: ApplicationComponent): ComponentDependencies @Binds @IntoMap @ComponentDependenciesKey(LocationDependencies::class) abstract fun provideLocationDependencies(component: ApplicationComponent): ComponentDependencies Изменить субкомпонент на компонент, или создать новый такого вида:  @PerActivity @Component( dependencies = [SettingsDependencies::class, LocationDependencies::class], //Необходимые зависимости  modules = [SettingsModule::class, SavedLocationInteractorModule::class] //Необходимые модули ) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } В Activity/Fragment код изменится подобным образом:  import com.avito.android.di.findComponentDependencies import com.avito.android.DaggerSettingsComponent ... DaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) ⚠️ Важно добавить в импортах перед SettingsComponent слово Dagger (DaggerSettingsComponent). Дело в том, что это кодогенерированный класс и на этапе написания кода он недоступен.\nСбилдить и запустить. Все готово!\nKnown Issues #  IDE не видит сгенерированные файлы #  Компонент отображается красным, как будто его нет.\n Проверь что файлы kapt не добавлены в исключения: Preferences \u0026gt; Editor \u0026gt; File Types \u0026gt; Ignore Files and Folders  Dagger: error.NonExistentClass cannot be provided / converted #  error.NonExistentClass cannot be provided without an @Inject constructor or an @Provides-annotated method e: MyClass.java:15: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass() ^ Dagger не видит этот класс из сгенерированного кода.\nПроверь что подключен соответствующий модуль с этим классом. Ошибка может врать, поэтому лучше проверить доступность всех классов, используемых в модуле.\n"});index.add({'id':26,'href':'/avito-android/docs/contributing/docs/','title':"Documentation",'section':"Docs",'content':"Documentation #  If the documentation is not good enough, people will not use what you do.\nStyle guide #  Write simply and to the point #  Documentation is intended to solve problems. Thus, it has to be simple and clear.\nWe can recommend several definitive guides on writing in general:\n The Elements of Style - William Strunk Jr. Пиши, сокращай (glvrd.ru - online checker)  Extra materials about technical writing:\n Jetbrains - Как писать полезные технические тексты Microsoft Writing Style Guide GitLab documentation styleguide What nobody tells you about documentation  Use appropriate format for the problem #  There is no universal documentation. It needs to be structured around problem and a level of knowledge:\n    Studying Working     Practical steps Tutorial How-to guide   Theoretical knowledge Explanation Reference    It\u0026rsquo;s ok to mix some types in one page:\n# Managing X Here goes short _explanation_ of X for new users. You can reference here to a detailed information. If I know this topic, I will skip it easily. ## Create a new X 1. Do ... \u0026lt;-- Short how-to guide 1. ... ## Move files to X Select ... Tutorial Analogy: teaching a child how to cook\nNaming:\n Getting started with X Writing your first test    Assist newcomers to get started Is learning-oriented Shows how to do in form of a lesson  The tutorial declares a goal in the beginning. After it guides by a series of steps. Each step is:\n Easy to follow Robust and reliable Gives a positive feedback by an immediate result Has as minimum theory as possible  Examples:\n Creating Web Applications with Flask   How-to guide Analogy: a recipe\nNaming:\n How to run tests in CI - 👍 Running tests - 👎 Tests in CI - 👎     Ориентация на практический результат: как решить проблему.\n  Ключевое отличие от tutorial: уже знакомы с продуктом.\nМожет адресовать проблему, которую новички могут даже не сформулировать.\n  Не объясняет концепции, может только ссылаться при необходимости.\n  Читатель понимает чего хочет достичь, но не знает как.\n  Шаги не такие надежные и повторяемые, читатель уже знаком с продуктом.\n  Шаги более гибкие\n  Описание не обязано быть полным, только то что нужно для проблемы.\n    Explanation Analogy: an overview article\nNaming: \u0026ldquo;Testing infrastructure in CI\u0026rdquo;\n Ориентация на понимание, не решает конкретных практических задач.\nЭто самый свободный формат описания. Описывает концепции, поясняет контекст и историю развития Дает альтернативные подходы и мнения, поясняет мотивацию   Reference Analogy: an article in Wikipedia\n  Ориентация на информацию: описать как устроено, как работает.\n  Отличие от tutorial, how to guide: не фокусируется на решении конкретных проблем, хотя и может приводить примеры использования.\n  Структура продиктована кодом, повторяет его\n  Описывает детали в точности как они работают.\n  Объясняет ситуацию как есть, не уходит в дискуссии, мнения, инструкции. Такие отвлечения мешают понять как работает.\n    Structure #  Вся документация состоит из набора markdown файлов.\nИспользуем генератор статических сайтов Hugo (тема - Book).\nДля проверки стиля - markdownlint\nMenu on the left #  Меню редактируется в docs/content/menu/index.md\nLinks #  Абсолютная ссылка: {{\u0026lt; ref \u0026quot;/Name.md\u0026quot; \u0026gt;}}, где путь относителен директории content/.\nОтносительная ссылка: {{\u0026lt; relref \u0026quot;Name.md\u0026quot; \u0026gt;}}.\nAnchor: {{\u0026lt; ref \u0026quot;/Name.md#header\u0026quot; \u0026gt;}}.\nПодробнее: cross references\nInternal links #  The documentation is public but some links and services are not.\nIn this case, define it clearly and in advance.\nTo be consistent we use a shortcode:\n{{\u0026lt; avito \u0026gt;}} This text contains Avito specific details  In this shortcode you can override the \u0026ldquo;text\u0026rdquo; word to be more clear:\n{{\u0026lt; avito section \u0026gt;}} This section contains Avito specific details  Also, you have to replace internal links by links.k.avito.ru shortener. It is available only in Avito.\\\nTo get links statistics add + to it.\nDiagrams #  Diagrams is a preferable way for schemes and processes.\nThey are cheaper in maintenance. Text is the source of truth.\nYou don\u0026rsquo;t need an original image and can edit it in a text editor.\nUse mermaid shortcode:\nLive editor\n{{\u0026lt;mermaid\u0026gt;}} stateDiagram [*] --\u0026gt; A A --\u0026gt; B B --\u0026gt; [*] {{\u0026lt;/mermaid\u0026gt;}}    mermaid.initialize({ flowchart: { useMaxWidth:true } });  stateDiagram [*] -- A A -- B B -- [*] Images #  Images are good for illustrating an explanation.\nUse any public file storage for them. For example, a Github CDN:\nThere is a html figure element for more control.\nHints #  {{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! {{\u0026lt; /hint \u0026gt;}} Markdown content\nLorem markdownum insigne. Olympo signis Delphis!  Buttons #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;http://repo/CONTRIBUTING.md\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Home  Contribute  Tabs #  {{\u0026lt; tabs \u0026#34;Unique ID\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;macOS\u0026#34; \u0026gt;}} macOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}  macOS macOS contentLinux Linux contentWindows Windows content Columns #  {{\u0026lt; columns \u0026gt;}} Left Content \u0026lt;---\u0026gt; Right Content {{\u0026lt; /columns \u0026gt;}} Left Content  Right Content   Details #  {{\u0026lt; details \u0026#34;Title\u0026#34; \u0026gt;}} Markdown content {{\u0026lt; /details \u0026gt;}} Title Markdown content   Math #  KaTeX\n{{\u0026lt; katex \u0026gt;}} \\overline{a \\lor b} = \\overline{a} \\land \\overline{b} {{\u0026lt; /katex \u0026gt;}}    \\(\\overline{a \\lor b} = \\overline{a} \\land \\overline{b}\\)  Lists #  Ordered vs Unordered lists #  Only use ordered list for describing a series of steps to follow.\nDo: 👍\nRun commands: 1. `cd dir` 1. `./prepare_data.sh` 1. `./publish_results.sh`   Don\u0026rsquo;t: 👎\nThere are two components in the system: 1. `Collector` 1. `Publisher`    Language #  Interaction with UI #   Use bold text for describing menu items and \u0026gt; as separator\nOpen Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Debugger Use exact words as shown in UI  Выделение терминов #  Выделяй символом ` команды, параметры, значения, имена файлов и т.п.:\n Добавь префикс Dagger в импортах перед Component Подключи модуль dagger Введи last в поиск Добавь параметр syncAvito в файл properties.ini  Не надо выделять все названия технологий, компаний и т.п. Это нагружает текст, его труднее читать:\n Для DI используем Dagger 👎  Changing documentation #  How to check changes locally #  Run docs/local.sh\nIt will open documentation at localhost:1313.\nYou can edit markdown files in the content/ on the fly. Changes out of this directory usually require a restart.\nBy default, we don\u0026rsquo;t publish draft, future and expired pages.\nTo publish them, add relevant argument to the command: docs/local.sh --buildDrafts\nChecklist for changes:\n Search Shortcodes: mermaid, \u0026hellip;  Working with custom shortcodes #  All custom shortcodes live in docs/layouts/shortcodes folder.\nYou can find them in markdown files by a filename - layouts/shortcodes/avito.html is {{\u0026lt;avito\u0026gt;}}.\nHugo troubleshooting\nHow to upgrade a theme #  Hugo theme is just a set of files in directory themes/\u0026lt;theme\u0026gt;. They are arranged by a specific layout.\nTo upgrade theme to a new version:\nDownload a source code of a new theme version; Replace docs/themes/book files by new ones; Remove useless example files in the book folder:  .github exampleSite images static/favicon.*   Keep workaround in themes/book/i18n/en.yaml for russian letters (see comments for bookSearchConfig.translation); Remove a mermaid shortcode (book/static/mermaid.min.js and book/layouts/shortcodes/mermaid.html). We have a custom one. Restart Hugo: docs/local.sh Check locally that everything is working as expected:  Custom shortcodes Searching in English and Russian text    How to upgrade Hugo #  Change the version in a Dockerfile; Publish the image by Build documentation docker configuration; Update a tag in ci/_environment.sh  "});index.add({'id':27,'href':'/avito-android/docs/contributing/featuretoggles/','title':"Feature toggle",'section':"Docs",'content':"Feature toggle #  This page contains Avito specific details   Feature toggle (Wikipedia) Feature toggle (Martin Fowler) Feature Toggles (Pete Hodgson)  Используется для уменьшения рисков при внедрении новой функциональности. Позволяет:\n Не держать изменения в отдельной ветке до окончания тестирования Отключить на этапе стабилизации, во время регрессионного тестирования  Cоздание #  Решение о создании feature toggle принимается на основе различных критериев:\n Изолированность изменений, насколько легко их отключить Риск привнести нестабильность  Реализация #   По умолчанию непротестированная логика должна быть отключена Отключать необходимо самым дешевым и надежным способом, с минимальным влиянием на логику Важно не сломать существующую логику, с отключенным feature toggle, т.к. это уже нельзя отключить  Отделение точки принятия решения от логики #  Feature toggle - это детали реализации, подверженные изменениям. При принятии решений в логике необходимо оперировать подходящим уровнем абстракции.\nОбычно хватает выделения этих знаний в функцию.\nfun shouldUseSessionInParameters() = not(features.sessionInHeader()) Инверсия решений #  Чтобы убрать из логики знания про реализацию, иногда дешевле переключать всю реализацию целиком:\n@Provides CommonChannelsInteractor provideInteractor(...) { return if (features.webSocketMessengerEnabled()) { MessengerCommonChannelsInteractorImpl(...) } else { ApiCommonChannelsInteractor(...) } } Тестирование #  Юнит тесты #  Для того, чтобы выявить все непредвиденные использования переключателей, не задаем никакого состояния по умолчанию. Это вынудит в тесте явно перебрать все состояния.\n@Mock private lateinit var features: Features Компонентные и функциональные тесты #  В таких тестах нет возможности изоляции логики и по умолчанию используем релизное состояние переключателей. Это компромиссный вариант, в котором делаем акцент на выявлении регрессии, а не на формальной проверке всех возможных состояний. Проверка всех состояний других фич не целесообразна.\nНеобходимы, как минимум, два набора тестов:\n Проверка регресса, старого поведения. Новая фича отключена, все остальные в состоянии по умолчанию. Проверка нового поведения. Новая фича включена, все остальные в состоянии по умолчанию.  Удаление #  Необходимо обязательно избавляться от устаревших переключателей. Но делать это можно только после того, как убедимся в работоспособности и стабильности решения. Исходя из целей, рекомендуется удалять после feature freeze.\n"});index.add({'id':28,'href':'/avito-android/docs/test/flakyannotation/','title':"Flaky Annotation",'section':"Docs",'content':"@Flaky Annotation #  What is flaky test #  A flaky test is a test that could fail or pass without project changes.\nOne could say this is unstable tests that fail sometimes but not every launch.\nIt happens when:\n test relies on an external environment: back-end, database, environment variables etc. test had written incorrect. Mistakes easy to do in async jobs. test framework has bugs  Flaky tests make hard:\n find real failures trust to test failures to react on failures as soon as possible \\  That\u0026rsquo;s why we introduce annotion to mark your test flaky.\nWe want:\n Minimize flakiness Launch as many tests as we can on pull request checks Help to fix common flaky problems  Annotation #  Mark flaky tests with special annotation - @Flaky\n@Flaky(reason = \u0026#34;Relies on real back-end\u0026#34;, onSdks = [22, 28]) class MyAwesomeTests { // ... }  reason - description of flakiness. You will see this reason in ReportViewer onSdks - specify if your test is flaking only on concrete sdk versions. When it\u0026rsquo;s empty all sdk versions will be marked flaky.  This annotation can be added both to the whole class and to a separate test:\nclass MyAwesomeTests { @Flaky @Test fun foobar() { // ...  } } Suppress @Flaky test failures #  By default @Flaky only adds flaky sign to ReportViewer. There are two options for changing @Flaky tests behavior:\n Add suppressFlaky = true to the uiTests step to suppress step failure because of @Flaky tests Add excludeFlaky = true to the filter for excluding @Flaky tests from execution  "});index.add({'id':29,'href':'/avito-android/docs/git/','title':"Git",'section':"Docs",'content':"Git #  Слияние веток #  Для слияния веток используем rebase. Это дает линейную историю и снижает нагрузку на CI. Пара команд может упростить вашу жизнь с rebase: git config rerere.enabled true \u0026ndash; автоматическое разрешение повторяющихся конфликтов при rebase git config pull.rebase true \u0026ndash; rebase при обновлении remote-ветки\nLocal Git hooks #  ./git_hooks будут синхронизированы с .git/hooks при первом запуске Gradle.\nGit LFS #  Могло быть полезно для хранения некоторых бинарных(или просто объемных) ресурсов в git. Например:\n изображения в документации эталоны скриншотов для тестов дизайн системы json для стабов в компонентных тестах  Не используем в проекте по ряду причин:\n нужно всем устанавливать git lfs локально, чтобы не коммитились ломающие изменения если ошибемся - переписывать историю нужно писать сервер-сайд хук, контролирующий чтобы не попадали изменения без lfs надеемся что битбакет сервер все делает правильно, а там это не прозрачно, bundled версия git и git lfs премердж наш должен учитывать lfs teamcity mirror репозиторий не работает с lfs, придется отключать похоже, а это оптимизация  "});index.add({'id':30,'href':'/avito-android/docs/contributing/howtostart/','title':"How to start",'section':"Docs",'content':"How to start #  This page contains Avito specific details  Minimal requirements #   16Gb RAM Linux/macOS/Windows  1. Установи Java #  Поддерживаем только Java 11.\n2. Установи Intellij IDEA или Android Studio #  Поддерживаем последнюю стабильную версию, но обычно работает и beta, и canary.\nДля обновлений рекомендуется JetBrains Toolbox.\nВ одном приложении доступны все IDE.\n3. Проверь проект #   Подключи VPN Запусти в корне проекта: ./gradlew help  Должно отработать успешно. Если упадет, прочитай текст ошибки и поправь.\n3. Настрой IDE #  Обнови Kotlin плагин до последней версии #  Preferences \u0026gt; Languages \u0026amp; Frameworks \u0026gt; Kotlin\nПодключи необходимые плагины #   Editorconfig - для code style  Включи оптимизации в IDE #  Ускорение IDE\n"});index.add({'id':31,'href':'/avito-android/docs/ide/benchmarking/','title':"IDE Benchmarking",'section':"Docs",'content':"Бенчмарки IDE #  This text contains Avito specific details  Используем Performance testing plugin.\nЧтобы плагин работал корректно на macOS, необходимо разрешить Android Studio/IntelliJ IDEA доступ к функциям Accessibility системы. Для этого:\n Открываем System Preferences \u0026gt; Security \u0026amp; Privacy Выбираем вкладку Privacy В списке слева находим пункт Accessibility Ставим галочку в списке справа для нужных приложений   Как попробовать? #   Установи плагин Запусти Help \u0026gt; Diagnostic \u0026gt; Execute Performance Script\u0026hellip; Выбери готовый сценарий из /benchmarks/ide и вставь содержимое скрипта в открывшееся диалоговое окно (содержимое выпадающего списка Please select scenario: не имеет значения)  Как проверить гипотезу и измерить разницу? #  Используем в ручном режиме:\n Прогони бенчмарк несколько раз до внесения изменений в проект Сохрани результаты. Они отобразятся в диалоге после прогона бенчмарка Внеси изменения в проект Прогони бенчмарк несколько раз, сравни результаты.  Что еще? #   Плагин умеет записывать YourKit snapshot с детальной информацией о всех вызовах методов.  "});index.add({'id':32,'href':'/avito-android/docs/ide/configurations/','title':"IDE Custom configurations",'section':"Docs",'content':"Кастомные конфигурации #  Шарим в проекте кастомные run/debug конфигурации, чтобы все работало \u0026ldquo;из коробки\u0026rdquo;.\nТак гарантируем одинаковые корректные настройки, случайно не сломается.\n  avito: собирает, устанавливает и запускает Авито.\n  avitoInstall: собирает и устанавливает Авито, но не запускает автоматически приложение.\nНужна из-за бага \u0026ldquo;Default activity not found\u0026rdquo;.\n  localCheck: проверка всех этапов компиляции с учетом импакт анализа\n  Как расшарить конфигурацию? #  Sharing Run/Debug Configurations\n"});index.add({'id':33,'href':'/avito-android/docs/ide/speedup/','title':"IDE Speedup",'section':"Docs",'content':"IDE Speedup #  To increase IDE performance you need to disable all unnecessary stuff and tune some settings.\nIncrease memory heap #  Increasing memory heap\nEnable remote build #  Mirakle\nDisable unnecessary modules #  This section contains Avito specific details  We develop all our Android applications in a single monorepo. If you work only with some apps you can disable others. To do so, disable relevant Gradle properties on a user level in ~/.gradle/gradle.properties:\nsyncAvito=false sync\u0026lt;app module\u0026gt; These flags are used in a simple way in settings.gradle:\nif (syncAvito.toBoolean()) { include(\u0026#34;:avito\u0026#34;) ... } else { logger.lifecycle(\u0026#34;Avito modules are disabled\u0026#34;) } Also, you can disable specific modules manually in IDE: Unloading modules\nDisable extra work on Gradle sync #   Preferences \u0026gt; Experimental \u0026gt; Only sync the active variant Preferences \u0026gt; Experimental \u0026gt; Do not build Gradle task list during Gradle sync  Reuse Gradle daemons #  Gradle can run multiple daemons if there are no compatible ones. You can see current Gradle daemons by this command:\n./gradlew --status To make Gradle daemons more reusable, you need to reuse the same JDK for all Gradle projects:\n Make sure you use an embedded JDK in Android Studio:  Specify this JDK in Gradle properties on a user level in ~/.gradle/gradle.properties:  org.gradle.java.home=\u0026lt;path to the embedded JDK\u0026gt; Disable unneeded plugins #  Android Studio comes with a lot of plugins. Ideally, they shouldn\u0026rsquo;t affect the performance if you don\u0026rsquo;t use them. To be sure and to avoid any possible overhead it\u0026rsquo;s better to disable that you don\u0026rsquo;t use. These are only the possible options:\n Android APK Support Android Games Android NDK App Links Assistant CVS, hg4idea, Subversion integration Firebase \u0026hellip; GitHub Google \u0026hellip; Task management Terminal Test recorder, TestNG YAML  Exclude project from indexing and antiviruses #  Gradle generates many files during a build. It\u0026rsquo;s extra work for antiviruses and any search indexing.\nExclude these directories:\n The project directory Android SDK Android Studio ~/.gradle ~/.android ~/.m2 ~/.gradle-profiler ~/gradle-profiler  macOS Add an exclusion to System preferences \u0026gt; Spotlight \u0026gt; Privacy.\ntip: press Cmd + Shift + . to see hidden files in Finder\nWindows Add an exclusion to Windows Security Ignore unneeded files #  build directories in modules contain many files. You can hide and ignore them from the Editor. We assume that any little bit can help to IDE.\nPreferences \u0026gt; Editor \u0026gt; File Types \u0026gt; Ignore Files and Folders\nSome intermediate build files are still needed for development.\n generated/source contains BuildConfig. apt, kapt, kaptKotlin contains files from annotation processors.  They will be unreachable in an editor and can break a refactoring.\n Free more memory #  Java are greedy for RAM. The worst case scenario is memory swapping.\nCheck it out, what applications can be shrinked.\nEnable power save mode #  The last resort is a power save mode. It disables code inspections and syntax highlighting in a current file.\nUse File \u0026gt; Power Save Mode or find an icon in a status bar.\n"});index.add({'id':34,'href':'/avito-android/docs/test_framework/internals/','title':"Internals",'section':"Docs",'content':"Internals #  Custom click #  It is a click without inter-process communication.\nMotivation to write custom click #  Espresso click uses inter-process communication. It leads to problems:\n Flaky clicks on moving views. Because click takes some time to touch after coordinates calculating. \u0026ldquo;misinterpret clicks as long clicks\u0026rdquo;  Implementation details #  Click happens via dispatch touch event on root view.\nKnown issues #   Can click through any system elements on the screen. It applies clicks directly on root view of our application. Because of it, crash or permission dialogs can be ignored by tests. Can click through separate decor view of our application. Sometimes we have multiple decor view in application (for example, when we have toolbar overflow menu). And that kind of click implementation can click through it. Overlapped view can\u0026rsquo;t handle click. We can\u0026rsquo;t realize when view is overlapped. Because of that clicks on overlapped views don\u0026rsquo;t work and don\u0026rsquo;t throw errors.  Overlapped view click details #  We tried to validate that click happens.\nWe were able to check that clicked view wasn\u0026rsquo;t overlapped, but faced scenario when user clicked on container and expected it to delegate click handling to child. We don\u0026rsquo;t want to restrict our user, because many tests behave like that.\n"});index.add({'id':35,'href':'/avito-android/docs/knownissues/','title':"Known Issues",'section':"Docs",'content':"Known Issues #  New Gradle Sync is not supported due to containing Kotlin modules #  Disable Settings \u0026gt; Experimental \u0026gt; Only sync the active variant\nhttps://stackoverflow.com/questions/54201216/android-studio-3-3-new-gradle-sync-is-not-supported-due-to-containing-kotlin-mo/\nInstrumentation tests run from Android Studio are failed with java.lang.NoClassDefFoundError #  The problem occurs when running a test from Android Studio because of generated Run Configuration has inappropriate type. Wherein test run from command line via ./gradlew test ends up normally.\nMostly this reproduced in tests that use Kotlin extensions from Test Fixtures from other Gradle modules.\nWorkaround:\n Use IntelliJ IDEA; Open **Settings \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle **; In drop-down menu Run test using select Gradle instead of IntelliJ IDEA; Then go to \u0026ldquo;Edit Configurations\u0026hellip;\u0026rdquo; (which is is the drop-down menu to the right of Run button); Remove old Run Configuration with \u0026ldquo;-\u0026rdquo; button; Run test again (make sure new configuration is created).  "});index.add({'id':36,'href':'/avito-android/docs/test/manual/','title':"Manual",'section':"Docs",'content':"Ручное тестирование #  This page contains Avito specific details  Обрати внимание на Типы Сборок\nГде взять сборку? #  QApps\n"});index.add({'id':37,'href':'/avito-android/docs/assemble/minimization/','title':"Minimization",'section':"Docs",'content':"Минимизация сборки #  This page contains Avito specific details  Официальная документация\nВ проекте используется R8 (задача (internal) на включение \u0026ldquo;full mode\u0026rdquo;)\nПараметры для сборки задаются в корневом gradle.properties\nВ каких типах сборки включена минимизация: Типы сборки\nStory \u0026ldquo;Защита от ошибок минификации кода\u0026rdquo; (internal)\nКонфигурация #  Общая конфигурация собирается по частям из нескольких источников. Помимо способов описанных в документации, конкретно в нашем проекте используется:\n $ANDROID_HOME/tools/proguard/proguard-android-optimize.txt базовый конфиг \u0026lt;app\u0026gt;/proguard/**/*.pro конфигурации разбитые по папкам-типам-сборки, а затем отдельным файлам зависимостям. Собираются в build.gradle при помощи своей функции proguardFromDir()  Посмотреть результирующий конфиг сейчас негде, есть задача (internal) на добавление его в артефакты\nТестирование #  Как запустить автотесты на сборке с минимизацией\nМатериалы по теме #   Как перестать бояться Proguard и начать жить Неофициальная документация  "});index.add({'id':38,'href':'/avito-android/docs/assemble/mirakle/','title':"Mirakle",'section':"Docs",'content':"Mirakle #  This page contains Avito specific details  Это Gradle плагин, который переносит сборку проекта на более мощную машину в дата центре. Компьютер во время сборки не так нагружен, можно продолжать работать с проектом.\nКак работает:\n  mermaid.initialize({ flowchart: { useMaxWidth:true } });  sequenceDiagram 💻-+Builder: Держи проект (rsync) Note right of Builder: Собираю Builder--💻: Получи что уже готово Builder--💻: Закончил Как настроить в первый раз? #   Установи rsync Посмотри какой host прописан в mirakle.py Проверь доступность удаленной машины по ssh (с VPN):\nssh [\u0026lt;username\u0026gt;@]\u0026lt;mirakle host\u0026gt;\nЕсли нет доступа:  Проверь есть ли уже ключ (checking for existing SSH keys) или сгенерируй новый. Нужен ключ без пароля, потому что из mirakle (Gradle) его некуда вводить. Добавь свой публичный ssh ключ - инструкция (internal)  Создай PR в указанный репозиторий Попроси в чатике #devops влить его   Запроси в Service Desk (internal) доступ по ssh на host android-builder   Включи mirakle: ./mirakle.py --enable. username будет взят из git user.email Проверь работу, запусти любую задачу: ./gradlew help\nВ логе будут сообщения:  Here's Mirakle ... :uploadToRemote :executeOnRemote :downloadInParallel  Проверь кастомные системные параметры сборки в ~/.gradle/gradle.properties\nОни не переносятся на удаленную машину. Выбираем один из вариантов:  Добавь в аналогичный файл на android-builder Добавь аргументами -Pname=value в Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Command-line Options\nNB: про такие настройки легко забыть, по возможности избегай их.    В следующие разы нужно только включать ./mirakle.py --enable\nКак отключить? #  ./mirakle.py --disable\nЧтобы отключить только для текущей сборки, добавь в аргументы Gradle -x mirakle\nПолное удаление настроек: /mirakle.py --wipe\nTroubleshooting #   Проверь что vpn подключен Проверь доступность mirakle, подключись по ssh  Known issues #  Сборка в mirakle идет дольше чем локальная #   Копирование проекта на другую машину занимает время. Если собираешь что-то небольшое, то сравни с локальной сборкой. Она может оказаться быстрее. На удаленной машине накопились старые файлы в проекте, rsync их не удалил.\nУдали их: ./clean.py --remote  Запустилось не то, что я запускал #  Проверь что синхронизация проекта проходит успешно.\n"});index.add({'id':39,'href':'/avito-android/docs/test_framework/mocking/','title':"Mocking in tests",'section':"Docs",'content':"Mocking in tests #  This page contains Avito specific details  To use a specific state you need to find a suitable @Rule or annotation.\nThus, test runner knows how to prepare it for the test (more details).\nMocks #  Networking #  Mocking a network on http layer #  @get:Rule val mockApi = MockWebServerApiRule() @Before fun setUp() { mockApi.registerMock( Mock( requestMatcher = { path.contains(\u0026#34;1/feature/item\u0026#34;) }, response = MockResponse().setBodyFromFile(\u0026#34;assets/mock/feature/api.feature.item/v1.default.json\u0026#34;) ) ) If you need to reuse a mocking logic, compose the rule into another rule:\n@get:Rule val mockApi = MockWebServerApiRule() @get:Rule val mockFeature = MockFeatureApiRule(mockApi) class MockFeatureApiRule(private val mockApi: MockWebServerApiRule) : SimpleRule() { override fun before() { ... Mocking a network on Retrofit layer #  @get:Rule val apiRule = MockApiRule() @Before fun setUp() { apiRule.stub { request\u0026lt;FeatureItemRequest\u0026gt;().success() } } All stubs are provided by ApiRequestsModule.\nUsing a real network implementation #  It\u0026rsquo;s a default behavior if you haven\u0026rsquo;t used any mocks for a network.\nOverride an API endpoint #  You can set a custom endpoint for API. It\u0026rsquo;ll be used for all request including internal integration services.\n@Host(\u0026#34;http://...\u0026#34;) class MyAwesomeTests {} Mocking analytics #  There are different options:\n MockAnalyticsRule: mocks analytics completely AnalyticsRule: only intercepts events and tries to not interfere with real implementation \u0026lt;test without rule\u0026gt;: real implementation  @get:Rule val analytics = AnalyticsRule() analytics.checks.assertEventTracked\u0026lt;ShowSearchEvent\u0026gt;() Mocking A/B-tests #  Make sure, you don\u0026rsquo;t use this in conjunction with mocking abtest list\u0026rsquo;s request.\n@get:Rule val abTests = AbTestsRule() @Before fun setUp() { with(abTests) { SimpleTestGroup.TEST.mockFor { publishServerDraft() } } } Mocking a location #  LocationRule serves for mocking location in tests.\n@get:Rule val locationRule = LocationRule() locationRule.setLocation(getTestLocation()) KEEP IN MIND that above rule does not mock location for the whole device but rather replace the best known location in BaseGeoProvider. That is technically possible that device location providers would give better location that was mocked. To avoid that mock location with high accuracy.\nMocking a User-Agent #  It is possible to mock User-Agent for test suite or for specific test with @UserAgent annotation. Here\u0026rsquo;s an example:\n@UserAgent(\u0026#34;AVITO 59.0 (Android 8.1.0; ru)\u0026#34;) class MyAwesomeTests {} This annotation is available in all types of tests but make sense mostly for functional tests.\nMocking a device id #  @DeviceId(\u0026#34;abcdefg123456\u0026#34;) class MyTest { ... } Writing custom mocks for tests #  Different tests need different mocks. We have to adapt an application state for these requirements.\nWe can define different types of tests:\n With mocked network With real network With mocked analytics \u0026hellip;  Trouble is, it leads to a combinatorial explosion.\nWe want to be sure that our changes in mocks for one test won\u0026rsquo;t break other tests. Therefore, it is better to have a straightforward and explicit relationship between a test and an application state.\nHow do we adapt an application state exclusively for one test?\n Test Runner starts before the application.\nSee InHouseInstrumentationTestRunner. Test Runner finds a test for running in arguments.\nIt parses test class (annotations, methods, rules) and saves this information into a Bundle.\nSee TestMetadataInjector The Test App reads parameters from InstrumentationRegistry.getArguments().\nNow we know requirements for the exact test and configure an application state with minimum side effects. The test is starting, and the application is already in the desired state.  "});index.add({'id':40,'href':'/avito-android/docs/architecture/modules/','title':"Modules",'section':"Docs",'content':"Modules #  This page contains Avito specific details  This page describes common structure of modules.\nModules grouping #  By application #  On the top-level all modules are grouped by application:\n  mermaid.initialize({ flowchart: { useMaxWidth:true } });  flowchart TB subgraph avito-app-modules[ ] avito--avito-modules[...] demo-app--avito-modules end subgraph domofond-app-modules[ ] domofond--domofond-modules[...] end subgraph common-modules[ ] common end avito-modules--common-modules domofond-modules--common-modules  avito, domofond: application modules. They only consume and wire features into an Android application. common modules: utilities, design components and so on. They are reused between different applications.  By layers #  Within one application modules are grouped by logical layers. It reduces coupling and helps to build faster.\nflowchart LR avito--avito-app avito-app--avito-libs avito-app--avito-api avito-libs--avito-api avito-libs--persistence avito-libs--core avito-app--persistence avito-app--core This scheme illustrates general principles and reasons for a decoupling.\nYou can find violations in the code. There are no excuses, it\u0026rsquo;s a tech debt.   avito-app: feature modules. They are used in application directly. avito-libs: smaller libraries. They are exists to reuse code between features. core: common code for all features.  Special cases #  These types of modules exist only due to technical limitations.\nModules for build types #  Android libraries have only a release (build variant). It helps to configure and build applications faster.\nplugins.withType\u0026lt;LibraryPlugin\u0026gt; { variantFilter { if (name != \u0026#34;release\u0026#34;) { ignore = true } } } Application modules have all build types. To consume release libraries we have to use special modules for build types.\nflowchart LR avito--|debugImplementation| avito-debug avito--|releaseImplementation| avito-release Modules for test fixtures #  Test fixture is the common practice in testing. They are auxiliary classes for tests.\nGradle has java test fixtures plugin, and it hasn\u0026rsquo;t supported in AGP yet (#139438142).\nThe workaround is to extract test fixtures to special \u0026ldquo;test\u0026rdquo; modules:\nflowchart TB application--|implementation| feature feature--|androidTestImplementation| test:feature test:feature--|implementation| feature application--|androidTestImplementation| test:feature "});index.add({'id':41,'href':'/avito-android/docs/test/performancetesting/','title':"Performance Testing",'section':"Docs",'content':"Performance Testing #  TBD\n"});index.add({'id':42,'href':'/avito-android/docs/assemble/profiling/','title':"Profiling",'section':"Docs",'content':"Профилирование сборки #  Чтобы посмотреть подробную информацию о скорости сборке попробуй разные инструменты, выбери наиболее простой.\nBuild Speed window (AS 4+) #   Собери проект View \u0026gt; Tool Windows \u0026gt; Build \u0026gt; Build Speed  Gradle build scan #  https://guides.gradle.org/creating-build-scans/\nЗапусти сборку с аргументом --scan:\n./gradlew build --scan Либо отправь с последней сборки:\n./gradlew buildScanPublishPrevious В конце лога будет ссылка на отчет.\nKnown issues:\n Не приходит первое письмо для активации ссылки:\nнапиши в help@gradle.com, приложи ссылку. This build scan cannot be viewed. A permanent error occurred processing the data.\nСкорее всего уперлись в лимит на размер скана. Нет способа проверить это заранее.\nПопробуй собрать что-то более мелкое и напиши в поддержку.  Avito build trace #  Build trace plugin\nGradle profiler #  В режиме профилировщика умеет запускать внешние профилировщики.\nПопробуй разные, тут нет однозначного победителя.\ngradle-profiler --profile async-profiler \\ --project-dir . \\ --warmups 1 \\ --gradle-user-home ~/.gradle-profiler \\ --output-dir profiler \\ help Android Tracer #  mirror-goog-studio-master-dev/tracer/\nЛегкий профилировщик от Google:\n Показывает исполнение кода из AGP внутри Gradle worker Можно разметить аннотациями свой код или указать в конфиге, что логировать  Как использовать:\n Запусти сборку с параметром android.enableProfileJson=true Открой файл build/android-profile в chrome://tracing  Кастомная конфигурация:\n Прочти README, есть неочевидные вещи. (jar файл нельзя переименовывать и т.п.) Выбери профиль, в репозитории есть пара под разные сценарии. Прокинь агент в демон, подходит GRADLE_OPTS:\nexport GRADLE_OPTS=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot; Добавь в jvm args в gradle.properties:\norg.gradle.jvmargs=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot;  Полезно посмотреть в образовательных целях, как пример профилирования с помощью java agent\n"});index.add({'id':43,'href':'/avito-android/docs/cd/qapps/','title':"QApps",'section':"Docs",'content':"QApps #  This page contains Avito specific details  QApps Android\nThis is the internal storage with builds for manual testing.\nWe publish builds automatically after merge to develop.\nКак залить вручную в QApps с ветки? #  Локально Для каждого приложения есть задача qappsUpload\u0026lt;build variant\u0026gt;.\nОна заливает уже собранную apk.\n Собери apk ./gradlew :avito:qappsUploadStaging -Pci=true\nЧтобы было проще найти сборку, укажи комментарий аргументом -PbuildNumber=\u0026quot;my custom build\u0026quot;  Known issues  Для релизной сборки не совсем подходит, т.к. не будет подписана релизным сертификатом. Чтобы отправить с другими versionName, versionCode нужно собрать приложение с этими параметрами.\nДля qapps это только комментарии к бинарнику. Даже если обмануть и залить apk в qapps указав другую версию, содержимое apk от этого не изменится.  CI Run uploadArtifacts Teamcity configuration.\nChoose your custom branch if needed. How to change upload settings? #  In build.gradle you can find uploadToQapps build step.\nThis build step defines artifacts to publish. See examples in uploadToQapps.\nWe run this step in uploadArtifacts Teamcity configuration.\n"});index.add({'id':44,'href':'/avito-android/docs/cd/release/','title':"Release",'section':"Docs",'content':"Релиз приложения Android #  This page contains Avito specific details  Канал для коммуникации: #regression-android\nDashboard релизов\nПолитика релизов мобильных приложений\n"});index.add({'id':45,'href':'/avito-android/docs/test/reportviewer/','title':"Report Viewer",'section':"Docs",'content':"Report Viewer #  This page contains Avito specific details  Используем отчеты в Report Viewer (internal), которые содержат:\n Видео с эмулятора  Только для упавших тестов Только для API 23+. На меньших версиях технологии не позволяют записывать надежно   Скриншоты: до и после каждого шага, во время падения Трейс ошибки: цепочка событий которая привела к ошибке Logcat для упавших тестов HTTP запросы и ответы во время шагов Логи запросов к ресурсам: Resource Manager, AB/test, Integration API, phones Логи действий тестового фреймворка  Using report viewer in a local run #  Report Viewer works in local runs too.\nSearch a link in a logcat by rv.k.\n"});index.add({'id':46,'href':'/avito-android/docs/analytics/statsd/','title':"Statsd",'section':"Docs",'content':"Statsd (Graphite) #  This page contains Avito specific details  Realtime-метрики для отслеживания текущего состояния.\nMonitoring (internal) - см. презентацию в самом начале.\nСм. использование StatsdEvent.\n"});index.add({'id':47,'href':'/avito-android/docs/tech_radar/techradar/','title':"Technology radar",'section':"Docs",'content':"Technology radar #  Technology radar is a list of technologies and practices that are described in the same manner:\n An overall status and recommendations for usage Limitations Reasons for choosing or declining  Original: https://www.thoughtworks.com/radar\nThe radar #   Gradle - buildSrc  Template\nFAQ #  Detailed FAQ\nWhat questions does tech radar help to solve? #   What criteria guide the choice? What should happen to reconsider the choice? I want to use X. How can I compare it against Y?  Do I have to use tech radar for all technologies? #  The harder to replace a technology, the more pragmatic we want to be.\nIt\u0026rsquo;s needless for something that can be replaced in a week or two.\nIs it mandatory or only recommendations? #  Tech radar helps to avoid a tragedy of the commons.\nWe all may have different opinions but we are in the same boat.\nTech radar can\u0026rsquo;t solve any conflict by itself. It only helps to share our knowledge and decisions.\nIn order to mitigate risks it has different statuses with different requirements.\nWhy don\u0026rsquo;t we use Avito\u0026rsquo;s tech radar? #  Stand-alone tech radar makes sense when you have dozens of services and repositories with the same common technologies.\nIn our case, such tech radar tends to become outdated. It\u0026rsquo;s easier to track changes and keep it up to date together with a product.\n"});index.add({'id':48,'href':'/avito-android/docs/tech_radar/template/','title':"Technology radar Template",'section':"Docs",'content':"The Name #  Quadrant: tools|techniques|platforms|languages \u0026amp; frameworks\nStatus (ring): hold|assess|trial|adopt\nThe description.\nFAQ\n"});index.add({'id':49,'href':'/avito-android/docs/test/testcaseincode/','title':"Test case in code",'section':"Docs",'content':"This page contains Avito specific details  Test case in code #  Avito uses in-house TMS: Internal docs\nTMS was a source of truth about test cases in avito since the very early days.\nWhile company shifted to test automation, manual synchronization between test cases in TMS and code in autotests became a problem.\\\nTo simplify this process \u0026ldquo;test cases in code\u0026rdquo; concept was born.\nNow only code contains truth about test cases, and automated ones are read-only in TMS.\nHow to synchronize your test with TMS? #  Test should have this minimal set of annotations:\n @ExternalId(UUID) UUID - random generated uuid (use any tool, for example online generator) @Description - testcase title @FeatureId(IntArray) - specify test\u0026rsquo;s place in global features tree @TagId(IntArray) - specify id\u0026rsquo;s of team tag cloud Kind  \u0026ndash; deprecated \u0026ndash;\n @CaseId(Int) - TMS id, consider using test case in code  Kind #  Kind has to be specified to map tests on test pyramid in TMS, see com.avito.report.model.Kind\nThese annotations also used to filter tests for different suites.\n @E2ETest - e2e functional tests @UIComponentTest - UI tests without(or minimal) e2e networking @IntegrationTest - Instrumentation tests without UI @UnitTest - Classical unit tests that should be synced with TMS @ManualTest @UIComponentStub @E2EStub @ScreenshotTest  When will my tests appear in TMS? #  After test with required annotations merged, next full suite test run will trigger sync process.\nInternal Teamcity configuration\nThis build runs every night, and it is recommended not to run this build manually only to sync a bunch of tests, because it\u0026rsquo;s fairly heavy.\nHow to find out why a test was not synced #  Let us know if something seems to go wrong.\nPlease attach:\n your pull request link nightly build that should trigger sync link test case id link in TMS (if it was edited, not a new one)  Stubs: tests without implementation #  If you need to sync tests, but you\u0026rsquo;re not ready to automate it, there is a way: stubs.\nStubs are tests with all needed meta information (annotations, steps), but without actual implementation and asserts.\nTo differentiate stubs from regular tests additional kind annotations were added.\nKind Manual are a special one, to express intention that there are no plans to automate this case.\nHow to generate a stub test #  To get help with moving test cases, check internal module\u0026rsquo;s :test:generator readme.\nThis project will generate test stubs from TMS id\u0026rsquo;s.\nHow synchronization works #    mermaid.initialize({ flowchart: { useMaxWidth:true } });  sequenceDiagram InstrumentationPlugin-ReportService: addTest() X times for whole suite InstrumentationPlugin-ReportService: setFinished() ReportService-TmsEventProcessor: event loop analyze TmsEventProcessor-TmsEventProcessor: just regular test run, skip end TmsPlugin-ReportService: pushPreparedData() TmsPlugin-ReportService: setFinished() ReportService-TmsEventProcessor: event loop analyze TmsEventProcessor-TmsEventProcessor: contains fresh(newest date) source of truth end loop analyze TmsEventProcessor-TmsEventProcessor: parse report and prepare payload for TMS end TmsEventProcessor-TMS: sendModifiedTestSuite() TMS Gradle plugin #  Project should apply and configure the plugin:\nplugins { id(\u0026#34;com.avito.android.tms\u0026#34;) } tms { reportsHost.set(\u0026#34;\u0026lt;report viewer host\u0026gt;\u0026#34;) } And also add a CI step\nbuilds { release { // build that contains full test suite  markReportAsSourceForTMS { configuration = \u0026#34;ui\u0026#34; // instrumentation configuration to wait for  } } } How to troubleshoot sync issues? #  Nightly build could be skipped if there are no code changes, keep it in mind while troubleshooting.   Nightly build log should contain line: [TMS] Test suite for tms version \u0026lt;timestamp\u0026gt;, with id: \u0026lt;id\u0026gt;, coordinates: \u0026lt;reportCoordinates\u0026gt; marked as source of truth for tms Check [TMS] tag in log for possible errors Check slack alerts channel: #tms-validation-errors Look at TMS sync service metrics:  Test case count (check aa/avito-android.total) Create/Delete events (check aa/avito-android.created and aa/avito-android.deleted)    "});index.add({'id':50,'href':'/avito-android/docs/test_framework/testframework/','title':"Test framework",'section':"Docs",'content':"Test framework #  ViewElement #  PageObject над View. Составляющие:\n InteractionContext - знания про родительский элемент, окружение Actions - действия с элементом Checks - проверки состояния  Создание #  Для создания используем фабричную функцию element:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) ViewMatcher будет учитывать родительский PageObject, унаследует его matcher.\nВложенные ViewElement #  Все PageObject могут быть вложенными, отражать реальную иерархию:\n// parent -\u0026gt; container -\u0026gt; button  val container: ViewElement = element(withId(R.id.container)) val button: ViewElement = container.element(withId(R.id.button)) Кастомный ViewElement #  Для переиспользования #  Бывает удобно отразить вложенность отдельным классом, чтобы переиспользовать в разных экранах.\n// parent --\u0026gt; selector --\u0026gt; hint  val selector: ImageSelectorElement = element(withId(R.id.selector)) class ImageSelectorElement(interactionContext: InteractionContext) : ViewElement(interactionContext) { val hint: ViewElement = element(withId(R.id.hint)) } Для кастомных actions, checks #  Еще одна причина для кастомного ViewElement - переопределить кастомные actions, checks. Примеры: RatingBarElement, BottomSheetElement.\nДля дефолтного Matcher #  Для переиспользуемых компонентов удобно держать внутри знания про дефолтный матчер.\nПри создании элемента будем только дополнять его, но не заменять.\nПока что не умеем модифицировать уже созданный interaction context, поэтому перехватываем при создании элемента:\nclass ElementWithEmbeddedMatcher : HandleParentContext, ViewElement { constructor(interactionContext: InteractionContext) : super(interactionContext.provideChildContext(defaultMatcher())) constructor(interactionContext: InteractionContext, matcher: Matcher\u0026lt;View\u0026gt;) : super(interactionContext.provideChildContext(Matchers.allOf( defaultMatcher(), matcher ))) } HandleParentContext - маркерный интерфейс. Изменяет поведение функции PageObject.element(matcher). Мы сами создаем дочерний контекст, потому что только мы знаем про дефолтный матчер.\nScreen #  Это PageObject для экрана (activity, fragment, dialog, \u0026hellip;)\nclass PublicProfileScreen : PageObject(), Screen { ... } rootId #  Явно связываем PageObject с конкретным layout:\noverride val rootId: Int = com.avito.android.public_profile_stuff.R.id.public_profile_screen_root  Помогает быстрее найти какой PageObject для этого экрана и в обратную сторону Все дочерние элементы в PageObject неявно проверяем на вхождение в этот layout Связывает экран с Gradle-модулем. Это нужно для работы импакт-анализа  Элементы #  PageObject содержит вложенные элементы:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) Используем фабричный метод element, чтобы создать вложенный элемент. При каждом действии или проверке автоматически проверяем какой экран сейчас отображается.\n"});index.add({'id':51,'href':'/avito-android/docs/ci/impactanalysis/','title':"Test impact analysis",'section':"Docs",'content':"Test impact analysis #  Test impact analysis finds automatically a minimum set of tests that can verify changed code.\nThe Rise of Test Impact Analysis\nOn module level #  Besides tests, we have different work to do in modules: Android Lint, unit-tests, assemble, \u0026hellip;\nIf a module is not affected by changes, we don\u0026rsquo;t want to run anything in it.\n  mermaid.initialize({ flowchart: { useMaxWidth:true } });  graph TD AppX -- FeatureA AppX -- FeatureB AppX -- FeatureC AppY -- FeatureC AppY:::changed -- FeatureD:::changed classDef changed fill:#f96; These optimizations are supported in CI Steps Plugin.\nSee implementation in impact module.\nUI tests #  An overview: Android CI Impact analysis - AppsConf Mobile meetup (RU).\nSee implementation in instrumentation-test-impact-analysis module.\nTradeoffs in impact analysis #  To bind a Page Object to a Gradle-module we keep this information in the code. See Screen.rootId\nThere are two types of errors in impact analysis:\n False-negative: haven\u0026rsquo;t run affected tests. False-positive: run extra tests.  There is a special case - fallback. If we can\u0026rsquo;t understand impact of changes, we ran all tests. We loose time in favor of correctness.\nKnown fallbacks:\n Fallback on test level: if a class has been changed, we\u0026rsquo;ll run all his tests. Fallback on module level: if a module has been changed, we\u0026rsquo;ll run all tests from its package. Fallback on Screen level: if we can\u0026rsquo;t find Screen\u0026rsquo;s package, we\u0026rsquo;ll run all tests related to it.  Screen doesn\u0026rsquo;t match any of packages Screen matches to multiple packages    "});index.add({'id':52,'href':'/avito-android/docs/test/runner/','title':"Test Runner",'section':"Docs",'content':"Avito test runner #  This is the Gradle plugin to run Android instrumentation tests.\nIt can do the following:\n Filter tests by annotations, by packages, by previous runs. Run tests in parallel. It orchestrates emulators in Kubernetes or uses local emulators. Rerun failed tests to deal with flakiness Save tests result in a report.\nIt uses an internal TMS (test management system). We are working on support other formats.  Getting started #   Apply the instrumentation-tests Gradle plugin \\  Kotlin Add to your build.gradle.kts\nplugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;com.avito.android.instrumentation-tests\u0026#34;) } Groovy Add to your build.gradle\nplugins { id(\u0026#34;com.android.application\u0026#34;) id(\u0026#34;com.avito.android.instrumentation-tests\u0026#34;) }   Add common plugin configuration Kotlin import com.avito.instrumentation.reservation.request.Device.LocalEmulator extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { // they are required for Avito app. We will make them optional in future.  reportApiUrl = \u0026#34;http://stub\u0026#34; reportApiFallbackUrl = \u0026#34;http://stub\u0026#34; reportViewerUrl = \u0026#34;http://stub\u0026#34; registry = \u0026#34;registry\u0026#34; sentryDsn = \u0026#34;http://stub-project@stub-host/0\u0026#34; slackToken = \u0026#34;stub\u0026#34; fileStorageUrl = \u0026#34;http://stub\u0026#34; configurationsContainer.register(\u0026#34;local\u0026#34;) { targetsContainer.register(\u0026#34;api28\u0026#34;) { deviceName = \u0026#34;API28\u0026#34; scheduling = SchedulingConfiguration().apply { quota = QuotaConfiguration().apply { retryCount = 1 minimumSuccessCount = 1 } reservation = TestsBasedDevicesReservationConfiguration().apply { device = LocalEmulator.device(28, \u0026#34;Android_SDK_built_for_x86_64\u0026#34;) maximum = 1 minimum = 1 testsPerEmulator = 1 } } } } } Groovy import com.avito.instrumentation.reservation.request.Device.LocalEmulator instrumentation { // they are required for Avito app. We will make them optional in future.  reportApiUrl = \u0026#34;http://stub\u0026#34; reportApiFallbackUrl = \u0026#34;http://stub\u0026#34; reportViewerUrl = \u0026#34;http://stub\u0026#34; registry = \u0026#34;registry\u0026#34; sentryDsn = \u0026#34;http://stub-project@stub-host/0\u0026#34; slackToken = \u0026#34;stub\u0026#34; fileStorageUrl = \u0026#34;http://stub\u0026#34; configurations { local { targets { api28 { deviceName = \u0026#34;API28\u0026#34; scheduling { quota { retryCount = 1 minimumSuccessCount = 1 } testsCountBasedReservation { device = new LocalEmulator(\u0026#34;28\u0026#34;, 28, \u0026#34;Android_SDK_built_for_x86_64\u0026#34;) maximum = 1 testsPerEmulator = 1 } } } } } } }    Run tests via Gradle task\n  ./gradlew :\u0026lt;projectPath\u0026gt;:instrumentation\u0026lt;ConfigurationName\u0026gt; In our case:\n./gradlew :\u0026lt;projectPath\u0026gt;:instrumentationLocal Examples #  Check out a configuration to run in GradleInstrumentationPluginConfiguration in the test app\nFiltering tests for execution #  You must apply a plugin Create filter  Kotlin extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { fromSource.includeByAnnotations(annotations) fromSource.excludeByAnnotations(annotations) fromSource.includeByPrefixes(prefixes) fromSource.excludeByPrefixes(prefixes) // it is internal for Avito. It uses run history from our test-report system.  fromRunHistory.excludePreviousStatuses(statuses) fromRunHistory.excludePreviousStatuses(statuses) fromRunHistory.report(\u0026#34;reportId\u0026#34;) { reportStatuses -\u0026gt; reportStatuses.include(statuses) reportStatuses.exclude(statuses) } } } Groovy import com.avito.instrumentation.reservation.request.Device.LocalEmulator instrumentation { filters { filterName { fromSource.includeByAnnotations(annotations) fromSource.excludeByAnnotations(annotations) fromSource.includeByPrefixes(prefixes) fromSource.excludeByPrefixes(prefixes) // it is internal for Avito. It uses run history from our test-report system.  fromRunHistory.excludePreviousStatuses(statuses) fromRunHistory.excludePreviousStatuses(statuses) fromRunHistory.report(\u0026#34;reportId\u0026#34;) { reportStatuses -\u0026gt; reportStatuses.include(statuses) reportStatuses.exclude(statuses) } } } }  Add filter to configuration  Kotlin extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { configurationsContainer.register(\u0026#34;local\u0026#34;) { filter = \u0026#34;filterName\u0026#34; // else...  } } Groovy instrumentation { configurations { local { filter = filterName // else...  } } }  Filter tests by annotations #  Kotlin extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { val yourFullyQualifiedAnnotationName = \u0026#34;package.AnnotationClassName\u0026#34; val annotations = setOf(youFullyQualifiedAnnotationName) // will include only tests with at least one annotation  fromSource.includeByAnnotations(annotations) // will exclude all tests with at least one annotation  fromSource.excludeByAnnotations(annotations) } } Groovy instrumentation { filters { filterName { def yourFullyQualifiedAnnotationName = \u0026#34;package.AnnotationClassName\u0026#34; def annotations = [youFullyQualifiedAnnotationName] as Set // will include only tests with at least one annotation  fromSource.includeByAnnotations(annotations) // will exclude all tests with at least one annotation  fromSource.excludeByAnnotations(annotations) } } }  Filter flaky tests #  Kotlin extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { fromSource.excludeFlaky = true } } Groovy instrumentation { filters { filterName { fromSource.excludeFlaky = true } } }  Filter tests by prefix or name #  Kotlin extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { val packageTestFilter = \u0026#34;testPackage\u0026#34; val classTestFilter = \u0026#34;testPackage.testClass\u0026#34; val fullyQualifiedTestFilter = \u0026#34;testPackage.testClass.testMetod\u0026#34; val prefixes = setOf(packageTestFilter, classTestFilter, fullyQualifiedTestFilter) // will include only tests from package, class and concrete test  fromSource.includeByPrefixes(prefixes) // will exclude all tests from package, class and concrete test  fromSource.excludeByPrefixes(prefixes) } } Groovy instrumentation { filters { filterName { def packageTestFilter = \u0026#34;testPackage\u0026#34; def classTestFilter = \u0026#34;testPackage.testClass\u0026#34; def fullyQualifiedTestFilter = \u0026#34;testPackage.testClass.testMetod\u0026#34; def prefixes = [packageTestFilter, classTestFilter, fullyQualifiedTestFilter] as Set // will include only tests from package, class and concrete test  fromSource.includeByPrefixes(prefixes) // will exclude all tests from package, class and concrete test  fromSource.excludeByPrefixes(prefixes) } } }  Filter tests by statuses from previous run on the same commit #  Kotlin import com.avito.instrumentation.configuration.InstrumentationFilter.FromRunHistory.RunStatus extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { val statuses = setOf(RunStatus.Success) // will run only Success previously Succeed tests  fromRunHistory.includePreviousStatuses(statuses) // will run all tests except previously Succeed  fromRunHistory.excludePreviousStatuses(statuses) } } Groovy import com.avito.instrumentation.configuration.InstrumentationFilter.FromRunHistory.RunStatus instrumentation { filters { filterName { def statuses = [RunStatus.Success] as Set // will run only Success previously Succeed tests  fromRunHistory.includePreviousStatuses(statuses) // will run all tests except previously Succeed  fromRunHistory.excludePreviousStatuses(statuses) } } }  Filter tests by statuses from report by id #  Kotlin import com.avito.instrumentation.configuration.InstrumentationFilter.FromRunHistory.RunStatus extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { // report-viewer report id  val reportId = \u0026#34;id\u0026#34; val statuses = setOf(RunStatus.Failed) fromRunHistory.report(reportId) { reportStatuses -\u0026gt; // will run only Failed tests from report  reportStatuses.include(statuses) // will run all tests except Failed tests from report  reportStatuses.exclude(statuses) } } } Groovy import com.avito.instrumentation.configuration.InstrumentationFilter.FromRunHistory.RunStatus instrumentation { filters { filterName { // report-viewer report id  def reportId = \u0026#34;id\u0026#34; def statuses = [RunStatus.Failed] as Set fromRunHistory.report(reportId) { reportStatuses -\u0026gt; // will run only Failed tests from report  reportStatuses.include(statuses) // will run all tests except Failed tests from report  reportStatuses.exclude(statuses) } } } }  Apply a filter without changing build.gradle.kts or build.gradle #   Add custom Gradle property for filter name to gradle.properties file  filterName=\u0026quot;default\u0026quot; Use the property to configure plugin  Kotlin import com.avito.kotlin.dsl.getOptionalStringProperty // read property val filterName: String? by project // or val filterName = project.getOptionalStringProperty(\u0026#34;filterName\u0026#34;, \u0026#34;default\u0026#34;) extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { configurationsContainer.register(\u0026#34;local\u0026#34;) { filter = filterName // else...  } } Groovy import static com.avito.kotlin.dsl.ProjectExtensionsKt.getOptionalStringProperty // read property def filterName = project.hasProperty(\u0026#34;filterName\u0026#34;) ? project[\u0026#34;filterName\u0026#34;] : \u0026#34;default\u0026#34; // or def filterName = getOptionalStringProperty(project, \u0026#34;filterName\u0026#34;, \u0026#34;default\u0026#34;) instrumentation { configurations { local { filter = filterName } } }  Add property to CLI command if you want to override filterName  ./gradlew instrumentationLocal -PfilterName=\u0026lt;any name of defined filter\u0026gt; Customize a filter without changing build.gradle.kts or build.gradle #  You can customize everything by adding custom properties to CLI command e.g.\n Define filter including tests by annotation Add logic to check presence of Gradle property.  Kotlin val includedAnnotation: String? by project // or val includedAnnotation = project.getOptionalStringProperty(\u0026#34;includedAnnotation\u0026#34;) extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { filters.register(\u0026#34;filterName\u0026#34;) { val annotation = if(includedAnnotation != null){ includedAnnotation } else { \u0026#34;package.AnnotationClassName\u0026#34; } val annotations = setOf(annotation) fromSource.includeByAnnotations(annotations) } } Groovy import static com.avito.kotlin.dsl.ProjectExtensionsKt.getOptionalStringProperty // read property def includedAnnotation = project.hasProperty(\u0026#34;includedAnnotation\u0026#34;) ? project[\u0026#34;includedAnnotation\u0026#34;] : null // or def includedAnnotation = getOptionalStringProperty(project, \u0026#34;includedAnnotation\u0026#34;) instrumentation { filters { filterName { def annotation = includedAnnotation ?: \u0026#34;package.AnnotationClassName\u0026#34; def annotations = [annotation] as Set fromSource.includeByAnnotations(annotations) } } }  Run Gradle task with property includedAnnotation to override filter  ./gradlew instrumentationLocal -PincludedAnnotation=\u0026#34;package.AnotherAnnotationClassName\u0026#34; Find out how filters were applied #  If build finishes successfully It will produce files with debug information Files will be located at:\n\u0026lt;Project root folder\u0026gt;/outputs/\u0026lt;subproject name\u0026gt;/instrumentation/\u0026lt;instrumentation task name\u0026gt;/filter\nFind out what filter config was #  Look at file filter-config.json\nFind out what filters applied #  Look at file filters-applied.json\nFind out what tests were filtered #  Look at file filters-excludes.json \\\n You may find filtered tests grouped by filter names declared in filters-applied.json You may find a filtered test by name  Choosing target for tests execution #  Run tests on kubernetes target from a local machine #  This text contains Avito specific details   Get access to kubernetes cloud: internal doc Request exec access to android-emulator namespace in beta cluster Setup a context on beta, android-emulator with your user access.\nMore about kubernetes context: Official docs Add a configuration with target on kubernetes  Kotlin import com.avito.instrumentation.reservation.request.Device.Emulator.Emulator28 configurationsContainer.register(\u0026#34;k8s\u0026#34;) { targetsContainer.register(\u0026#34;api28\u0026#34;) { deviceName = \u0026#34;API28\u0026#34; scheduling = SchedulingConfiguration().apply { quota = QuotaConfiguration().apply { retryCount = 1 minimumSuccessCount = 1 } reservation = TestsBasedDevicesReservationConfiguration().apply { device = Emulator28 maximum = 1 minimum = 1 testsPerEmulator = 1 } } } } Groovy import static com.avito.instrumentation.reservation.request.Device.Emulator.Emulator28 instrumentation { configurations { k8s { targets { api28 { deviceName = \u0026#34;API28\u0026#34; scheduling { quota { retryCount = 1 minimumSuccessCount = 1 } testsCountBasedReservation { device = Emulator28.INSTANCE maximum = 1 minimum = 1 testsPerEmulator = 1 } } } } } } }  Run tests with extra parameters specified.  ./gradlew :samples:test-app:instrumentation\u0026lt;configuration name\u0026gt; -PkubernetesContext=\u0026lt;your context\u0026gt; // for Avito probably \u0026#39;beta\u0026#39; We will looking for .kube/config in your $HOME\nRun tests on local emulator target #  Add a configuration with target on local emulator  Kotlin import com.avito.instrumentation.reservation.request.Device.LocalEmulator extensions.getByType\u0026lt;GradleInstrumentationPluginConfiguration\u0026gt;().apply { configurationsContainer.register(\u0026#34;local\u0026#34;) { targetsContainer.register(\u0026#34;api28\u0026#34;) { deviceName = \u0026#34;API28\u0026#34; scheduling = SchedulingConfiguration().apply { quota = QuotaConfiguration().apply { retryCount = 1 minimumSuccessCount = 1 } reservation = TestsBasedDevicesReservationConfiguration().apply { device = LocalEmulator.device(28, \u0026#34;Android_SDK_built_for_x86_64\u0026#34;) maximum = 1 testsPerEmulator = 1 } } } } } Groovy import com.avito.instrumentation.reservation.request.Device.LocalEmulator instrumentation { configurations { local { targets { api28 { deviceName = \u0026#34;API28\u0026#34; scheduling { quota { retryCount = 1 minimumSuccessCount = 1 } testsCountBasedReservation { device = new LocalEmulator(\u0026#34;28\u0026#34;, 28, \u0026#34;Android_SDK_built_for_x86_64\u0026#34;) maximum = 1 testsPerEmulator = 1 } } } } } } }   Run an emulator with 28 API Run Gradle CLI command  `./gradlew :\u0026lt;project gradle path\u0026gt;:instrumentation\u0026lt;configuration name\u0026gt;`, e.g. `./gradlew :samples:test-app:instrumentationLocal` Run test on APK was built before #  Plugin builds APKs on his own by default.\nIf for any reason you have to build APK externally, you can pass files manually:\n// optional applicationApk = \u0026#34;/path/to/app.apk\u0026#34; // optional testApplicationApk = \u0026#34;/path/to/test-app-debug-androidTest.apk\u0026#34; Run tests on Google Cloud Platform #  Work in progress\nCreate and configure Kubernetes cluster TODO 0. Create a node pool. Node must contain CPU that supports KVM https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances#gcloud Add configuration for your cluster to ./kube/config Providing credentials to the application https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application TODO 0. Run on local machine TODO 0. Run locally gcloud auth application-default login one time will be enough 0. Run ./gradlew \u0026lt;instrumentationTaskName\u0026gt; -PkubernetesContext=\u0026lt;context from ./kube/config\u0026gt; 0. Run on CI Customize deployment TODO 0. Custom POD image 0. Customize POD cpu and ram 0. Custom namespace  "});index.add({'id':53,'href':'/avito-android/docs/test/testminimized/','title':"Testing a minimized build",'section':"Docs",'content':"Testing a minimized build #  About minimization: link\nWe want to run UI tests against build as close as possible to a production one.\nIt\u0026rsquo;s quite a challenging task, mostly because of tooling problems: #126429384\nDevelopers should maintain a list of keep rules of code referenced from a test app manually.\nWe work around these problems by using keeper.\nBuild type #  Our build types: link\nAndroid Gradle plugin uses testBuildType property to determine which build type to test.\nWe chose stagingAutoTest as a type to test against in CI environment.\nHowever local builds defaults to debug type for faster test writing cycle.\nDeveloper who wants to reproduce test problem specific to CI locally, should temporary change \u0026lt;app name\u0026gt;.testBuildType property to stagingAutoTest in ~/.gradle/gradle.properties.\nSample #  You can check an example in the :test-app module.\nKnown issues #  Dynamically referenced resources #  You can see in PageObjectTest, that we referenced R.layout.page_object_1, dynamically creating layout.\nThese layouts referenced nowhere in app code, so if shrinkResources enabled you will face strange error:\nerror inflating class x Caused by: java.lang.ClassNotFoundException: Didn\u0026#39;t find class \u0026#34;android.view.x\u0026#34; on path: DexPathList What it really hides, R.layout.page_object_1 got shrinked to:\n\u0026lt;x /\u0026gt; If this is your case, add these resources to res/raw/keep.xml like this:\n\u0026lt;resources xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; tools:keep=\u0026#34;@layout/page_object*\u0026#34;/\u0026gt; X already has a mapping #  Issue #122924648 - Solved in a 1.6.x\nSome issues could be solved in a new version of r8, you should consider upgrading before hacking further.\nBy default, r8 bundled with Android Gradle plugin, but you can override it.\nbuildscript { val r8Version: String by project repositories { maven { setUrl(\u0026#34;http://storage.googleapis.com/r8-releases/raw\u0026#34;) } } dependencies { classpath(\u0026#34;com.android.tools:r8:$r8Version\u0026#34;) // \u0026lt; it should be added before android Gradle plugin  } } For versions check tags here: https://r8.googlesource.com/r8/\nSeems like 1.5 versions bundled with AGP 3.5.x\n1.6 -\u0026gt; 3.6.x\nand 2.0 -\u0026gt; 4.0.x\n Don\u0026rsquo;t forget to tell keeper, you are using different r8 version:\ndependencies { keeperR8(\u0026#34;com.android.tools:r8:$r8Version\u0026#34;) }   Still NoSuchMethodError #  Take a look at module :subprojects:android-test:keep-for-testing for additional keep annotations.\nIt\u0026rsquo;s a workaround described here: Issue #143419092\nYou still need to add proguard rules as pointed in annotation classes comments.\n Why not package proguard rules?\n In this case, rules go into all variants, and you only want a tested one.\n Why not use original @Keep?\n Just to distinguish an intent, it\u0026rsquo;s for testing and only in a tested variant\n"});index.add({'id':54,'href':'/avito-android/docs/test/toast/','title':"Testing toasts",'section':"Docs",'content':"Testing toasts #  android.widget.Toast\nTesting toasts is a hard because other toasts can show up and yours will be queued. We hack app with proxy object to mitigate this.  It is also recommended to use snackbar, or your custom way to display brief unintrusive messages instead. So you should consider not testing it at all.  Proxy toast #  Use provided extension methods to be able to spy on showToast functions.\nimport com.avito.android.util.showToast showToast(\u0026#34;I\u0026#39;am a toast!\u0026#34;) implementation(\u0026#34;com.avito.android:proxy-toast:$version\u0026#34;) ToastRule #  @get:Rule val toastRule = ToastRule() fun test() { toastRule.checks.toastDisplayedWithText(\u0026#34;I\u0026#39;am a toast!\u0026#34;) } androidTestImplementation(\u0026#34;com.avito.android:toast-rule:$version\u0026#34;) "});index.add({'id':55,'href':'/avito-android/docs/assemble/troubleshooting/','title':"Troubleshooting",'section':"Docs",'content':"Troubleshooting #  This page contains Avito specific details  Что делать в случае непонятной ошибки? #  Ситуация: падает или подвисает синхронизация проекта или сборка. По ошибке ничего не понятно.\nЧтобы найти причину, проще всего последовательно исключать возможные причины.\n Исключи влияние локальных изменений: переключись на свежий develop, убери все локальные изменения Проверь что включен VPN Исключи влияние mirakle: ./mirakle.py -d Исключи влияние IDE: проверь сборку из консоли Проверь не переопределено ли что-то подозрительное в ~/.gradle/gradle.properties Убедись что конфигурация проекта проходит успешно: ./gradlew help Посмотри детальную ошибку: ./gradlew \u0026lt;failed task\u0026gt; --stacktrace Исключи влияние кеширования: ./gradlew \u0026lt;failed task\u0026gt; --no-configuration-cache --no-build-cache\nОчистить кеш можно командой: ./gradlew cleanBuildCache  Если проблема воспроизводится только в IDE #  В консоли отработало без ошибок, но в IDE падает или подвисает.\n Проверь версию IDE и Kotlin плагина. Возможно они слишком старые или наоборот, alpha/beta версии. Добавь --stacktrace чтобы увидеть детали ошибки:\nSettings \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Command-line Options:_ Проверь что не включен offline mode на вкладке Gradle Возможно ошибка в .iml, .idea/ файлах:  ./clean.py --all или File \u0026gt; Re-Import Gradle project File \u0026gt; Invalidate Caches / Restart   Отключи все прокси (Charles и т.п.). Они могут перехватывать по ошибке лишние запросы из IDE и сборки. Посмотри логи Help \u0026gt; Show log in Finder  Если причина в Mirakle #  Возможно из mirakle прилетают некорректные данные. Удали их: ./clean.py -r\nЕсли ничего не помогло #   Отправь build scan:\n./gradlew \u0026lt;task\u0026gt; --scan или ./gradlew buildScanPublishPrevious; Напиши в #android-dev или #speed, приложи ссылку на build scan и все что удалось проверить.  Как искать проблемы с кешированием? #  Gradle - Using build cache\nKnown issues #  D8: Dex file with version \u0026lsquo;N\u0026rsquo; cannot be used with min sdk level \u0026lsquo;M\u0026rsquo; #  Dex file with version '38' cannot be used with min sdk level '22'. D8 com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives Предположительно возникает после изменений в плагинах.\nПомогает ./clean.py -a\n"});index.add({'id':56,'href':'/avito-android/docs/test/troubleshootingui/','title':"Troubleshooting UI Tests",'section':"Docs",'content':"Troubleshooting #  Known issues #  All known bugs: jira filter (internal)\nCamera auto-focus hangs up on 22 API #  #139438163\nThere is no workaround. Skip test on this API level.\nError in local run: \u0026ldquo;Test framework quit unexpectedly\u0026rdquo; #  Usually it indicates a problem in test runner, see logcat for errors.\nIn some cases test can run without problems. Use a local test report\nКак понять почему упал тест? #  Посмотри в TeamCity, в тесте краткая выжимка о причинах падения и ссылка на отчет в Report Viewer\nHow to deal with flaky test #  Работа с флакующими тестами\n"});index.add({'id':57,'href':'/avito-android/docs/test/unittesting/','title':"Unit tests",'section':"Docs",'content':"Unit tests #  How to write good tests (mockito)\nAssertions #  Рекомендуется использовать assertThat() вместо assertEquals() и т.п.\nМотивация #  Типизация #  assertEquals(\u0026quot;id\u0026quot;, 1L) - падает только в рантайме assertThat(\u0026quot;id\u0026quot;, 'is'(1L)) - проверка при компиляции\nЧитаемость #  assert \u0026ldquo;equals 3 x\u0026rdquo; assert \u0026ldquo;x is 3\u0026rdquo; - естественный порядок\nКомбинирование условий #  either(s).or(not(t)) each(s) И т.п. особенно с кастомными матчерами.\nСообщения об ошибках #  assertTrue(response.contains(\u0026#34;color\u0026#34;) || response.contains(\u0026#34;colour\u0026#34;)) // java.lang.AssertionError // at org.junit.Assert.fail(Assert.java) // at org.junit.Assert.assertTrue(...) // и т.п., никаких подробностей assertThat(response, anyOf(containsString(\u0026#34;color\u0026#34;),containsString(\u0026#34;colour\u0026#34;))) // java.lang.AssertionError: // Expected: (a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // but: was \u0026#34;...\u0026#34; // Expected :(a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // Actual :\u0026#34;...\u0026#34; Matchers #  Создание #  Для создания рекомендуется использвать фабричные методы:\nimport org.hamcrest.Matchers.hasSize assertThat(collection, hasSize(1)) Мотивация: меньше завязываемся на детали реализации, внутренние классы библиотеки.\nВерификация #  Необходимо проверять корректность использования Mockito. Для этого можно использовать Mockito.validateMockitoUsage() либо MockitoJUnit. Мотивация: нестабильные тесты. Нарушение контракта Mockito не приводит сразу к падению, но может влиять на другие тесты. Из-за параллельного запуска падать будут в произвольных местах.\n"});index.add({'id':58,'href':'/avito-android/docs/test/workmanager/','title':"Work Manager Testing",'section':"Docs",'content':"Work Manager Testing #  This document describes how to test WorkManager\u0026rsquo;s Workers.\nHow to test WorkManager\u0026rsquo;s Workers? #  The best way to test your Workers is the way described in official documentation. In short, you can test your Workers directly without initializing WorkManager.\nWorkManager is disabled for tests #  Because using real WorkManager while testing involves a lot of problems as it starts to initialize just before AvitoTestApp (using ContentProvider mechanism). Sometimes it leads to a classic race condition: some Worker tries to get its dependencies to build its own Dagger graph but Application isn\u0026rsquo;t ready so test runner ends up with a crash.\n"});index.add({'id':59,'href':'/avito-android/docs/assemble/benchmarks/','title':"Бенчмарки сборки",'section':"Docs",'content':"Бенчмарки сборки #  This page contains Avito specific details  Для бенчмарков используем Gradle profiler, где можно описать воспрозводимый сценарий:\n Редактировать java/kotlin файлы, Android ресурсы Переключаться между коммитами Проверить на разных версиях Gradle Почистить кеш, сборку Учесть прогрев перед измерениями  How to start #   Установи с помощью sdkman:  sdk install gradleprofiler или скачай готовые бинарники: Installing.\n Опиши свой сценарий. Возьми за основу один из готовых из ci/profiler/benchmarks.scenarios и посмотри какие операции необходимы.  Меняем код и ресурсы в модуле serp-core и собираем avito:\nserp_avito_assemble { tasks = [\u0026#34;:avito:assembleDebug\u0026#34;] apply-abi-change-to = \u0026#34;avito-libs/serp-core/src/main/java/com/avito/android/serp/SerpResult.kt\u0026#34; apply-android-resource-change-to = \u0026#34;avito-libs/serp-core/src/main/res/values/strings.xml\u0026#34; } Сохраняем сценарий в файл.\n Запусти профайлер:  gradle-profiler --benchmark \\  --project-dir . \\  --warmups 2 \\  --iterations 5 \\  --gradle-user-home ~/.gradle-profiler \\  --output-dir benchmarks/output \\  --scenario-file scenarios \\  serp_avito_assemble Все параметры запуска\nЧто измеряем в CI? #  Измеряем сценарии из ci/profiler/benchmarks.scenarios.\nЗапускаем в develop в конфигурации Profiler build (internal). Собираем только пару раз в день, потому что на каждый коммит не хватает железа.\nDashboard (internal) с этими сценариями.\n"});index.add({'id':60,'href':'/avito-android/docs/test/run/','title':"Запуск тестов",'section':"Docs",'content':"Запуск тестов #  This page contains Avito specific details  Автоматически запускаемые тесты #  Тесты на PR #  При создании Pull Request\u0026rsquo;а ваша ветка ребейзится на целевую ветку и автоматически запускается fastCheck, объявленный в avito/build.gradle:\n Юнит тесты Инструментальные тесты (кроме помеченных аннотацией @Flaky):  Перформанс Компонентные Скриншотные Интеграционные (@IntegrationTest)   Android Lint  Проверки develop\u0026rsquo;а #  Раз в 3 часа при наличии изменений в develop-ветке на ней запускается fullCheck, объявленный в avito/build.gradle и содержищий следующие проверки:\n Юнит тесты Инструментальные тесты:  Компонентные E2E Скриншотные Интеграционные (@IntegrationTest)   Android Lint  Тесты, почеменные как @Flaky запускаются, но на результат прогона не влияют.  Регресс #  Регресс автоматически запускается каждый день таким образом, чтобы к началу рабочего дня уже был как минимум один прогон, а к началу регресса - несколько прогонов для выявления флаки тестов. За регресс отвечает конфигурация release, объявленая в avito/build.gradle. Результаты прогонов агрегируются в отчет по коммиту, с которого был запущен регресс, и упавшие тесты рассылаются ответственным юнитам в соответствующие чаты в Slack. Имя пакета теста отображается на имя канала в словаре unitToChannelMap здесь (ссылка на внутренний ресурс).\nРегресс включает в себя:\n Юнит тесты Инструментальные тесты:  Компонентные E2E Скриншотные Интеграционные (@IntegrationTest)   Android Lint  Пожалуйста, не запускайте эту конфигурацию руками. Это приведет к рассылке уведомлений в каналы юнитов в Slack, что зря потревожит ответственных. Можно прогнать аналогичный набор тестов и другим образом.  Запуск тестов вручную #  В IDE #  Обрати внимание на кастомные конфигурации\nЗапуск Robolectric тестов #  Просто запускаем стрелками Run напротив имени тестового класса или метода.\nЗапуск Instrumentation тестов #  Аналогично Robolectric тестам - просто запускаем тест средствами Android Studio.\nЗапуск тестов в CI с кастомными параметрами #   Перейдите на конфигурацию instrumentationDynamic Нажмите Run  В появившемся окне настройте окружение для запуска  Во вкладке Changes  Build branch - ветка для запуска тестов   Во вкладке Parameters  Test URL - опциональный. API URL, в который ходят тесты env.DYNAMIC_FILTER - опциональный. Фильтр по типам тестов  ui \u0026ndash; компонентные, E2E, скриншотные, интеграционные тесты uiNoE2E \u0026ndash; как ui, но без E2E тестов regressionNoE2E \u0026ndash; uiNoE2E + ручные тесты regression \u0026ndash; ui + ручные тесты   Package prefix - опциональный. Фильтр по имени теста. package.ClassName.methodName  package - отфильтровать по пакету package.ClassName - отфильтровать по классу package.ClassName.methodName - отфильтровать по методу в классе   Retry count - обязательный. Кол-во запусков. Полезно для отладки нестабильных тестов [22, 23, 24, 28] Api - должен быть выбран минимум 1. На каких API запускать тесты      Как прогнать полный набор тестов (как на регрессе) #  Для запуска набора тестов, аналогичного регрессу (но без рассылки репортов в юниты), воспользуйтесь TeamCity конфигурацией fullCheck. В настройках запуска можно задать следующие параметры:\n Ветку для запуска (Changes -\u0026gt; Build branch) API URL, в который ходят тесты (Parameters -\u0026gt; Test URL)  Локальный запуск тестов в инфре #  Сейчас в разработке находится механизм локального запуска инструментальных тестов на эмуляторах в кубе. Уже работает для тестового приложения в инфре. Подробности здесь.\n"});index.add({'id':61,'href':'/avito-android/docs/test/flakytests/','title':"Нестабильные тесты",'section':"Docs",'content':"Нестабильные тесты #  This page contains Avito specific details  Что не надо делать #   Игнорировать тесты в TeamCity. Вы просто \u0026ldquo;подложите свинью\u0026rdquo; своим коллегам в будущем. Помечать тест как @Ignore. Есть специальная аннотация @Flaky.  Убедись что тест действительно флакует #   Посмотри в чаты #android-dev или #android-autotesting. Вероятно, проблема уже известна. Посмотри статистику стабильности теста Запусти тест для проверки в несколько прогонов в динамической конфигурации.  Отлаживай в IDE #  В Android Studio должен из коробки работать debug на конкретном тесте.\nhttps://developer.android.com/studio/debug\nLayout Inspector #  Layout inspector использует adb поэтому мы не можем получить состояние экрана в дебажном запуске.\nКак получить экран во время прогона теста?\n Добавить в нужное место Thread.sleep(). Запустить тест без дебага и дождаться пока исполнение попадет в Thread.sleep() Задампить состояние экрана через Layout Inspector  Если не удалось найти причину #   Обратись к автору тесту или юниту, который за него отвечает. Если тест уже чинят, то можно дождаться фикса. Если проблема новая, то договоритесь о том, кто поставить аннотацию @Flaky на тест. В аннотации обязательно укажите причину, а лучше задачу, в которой тест будет исправлен. Можно также приложить ссылку на build или репорт в RV. Запушьте изменения  Если проблема никак не решается #   Обратись за помощью Приложи сылку на репорт. Помогут также логи с ошибками.  Где посмотреть статистику по стабильности тестов? #   Общая статистика по тестам (internal) История нестабильности теста (internal)  Обратите внимание на параметры фильтрации.\nКогда убирать аннотацию @Flaky #  Если вы внесли изменения, которые чинят исходную причину флакования теста, то в том же PR необходимо убрать аннотацию с починенных тестов.\nТакже можно ориентироваться на статистику в BI.\n"});index.add({'id':62,'href':'/avito-android/docs/performance/analytics/','title':"Реалтайм-аналитика",'section':"Docs",'content':"Замеры перформанса экрана (internal) #  Что умеем замерять #  Пользовательские метрики #   время от тача до начала инициализации экрана (предынициализация) время от тача до окончания отрисовки каждого из потоков данных экрана  Этапы работы экрана #   время инициализации экрана (ScreenInitTracker) время DI экрана (ScreenDiInjectTracker) время загрузки данных по сети и с диска (наследники ContentLoadingTracker) время обработки данных, например конвертации сетевых моделей в презентационные (ViewDataPreparingTracker) - не всегда используется, потому что не везде есть время отрисовки (с момента посылки команды на отрисовку до того как соответсвующий Runnable отработал на main thread) длительность инициализации и DI компонентов (сабмодулей)  Отправляем метрики в statsd для realtime-аналитики и clickstream для AB-тестирования и детального анализа.\nПользовательские метрики отражают ожидания пользователя: тапнул по экрану - получил, что хотел.\nЧто нужно знать перед написанием кода #   определить тип экрана (с предзагрузкой данных, самостоятельный, субкомпонент) создать абстракцию трекера экрана в соответствии с флоу экрана Типы флоу экранов добавить замеры в код синхронизировать имя вашего экрана (screenName) и замеряемые типы контента с таблицей (согласовать имена с iOS-платформой) проверить на дашборде, что ваши замеры действильно отправляются  Типы замеряемых экранов #  Самостоятельный экран #   Activity без фрагментов Activity с Fragment, если он один на экране Конфигурация в которой есть Activity и несколько фрагментов одновременно на экране (В этом случае фрагменты выступают субкомпонентами)  Cубкомпонент #   Fragment, который является одним из нескольких отображаемых фрагментов самостоятельного экрана (публичный профиль, главная, etc) Fragment, который является одним из шагов какого-нибудь флоу (подачи, выставления рейтинга продавцу, etc)  Если вы хотите все шаги какого-нибудь флоу затрекать как самостоятельные экраны, это также валидно. Рассматривать фрагмент как самостоятельный экран, так как и как субкомпонент в этом случае - вопрос предпочтений. Фрагмент, покрытый аналитикой, может и должен уметь выступать как самостоятельным экраном, так и субкомпонентом (элементом экрана).\nЭкран с предзагрузкой данных #  Когда экран осуществляет сетевые запросы и подготовку данных для отображения на следующем экране. Например, при выставлении рейтинга продавцу, сначала нажимаем на рейтинг, открывается фейковый экран с лоадером. Этот экран запрашивает данные для отображения следующего экрана, который будет известен по итогам запроса. Если авторизация есть - переходим на флоу выставления рейтинга, если нет - на авторизацию. С точки зрения пользователя: нажал на рейтинг, появился лоадер, появился экран выбора объявления, по которому будет выставляться рейтинг. Разумно считать, что этап предварительной подготовки для экрана с выбором объявления является частью флоу рейтинга.\nТипы трекеров #   ScreenDiInjectTracker - трекает время инициализации DI и время предынициализации (от тача до начала DI) Время предынициализации трекается автоматически. ScreenInitTracker - время инициализации (создание и подключение презентеров, роутеров, вью) LocalContentLoadingTrackerImpl - загрузка одного из потоков данных из локального хранилища, скажем из префов ServerContentLoadingTrackerImpl - загрузка одного из потоков данных с сервера ViewDataPreparingTracker - подготовка данных для экрана (конвертация сетевых моделей в презентационные, например) ContentDrawingTracker - отрисовка данных. Через handler.post учитываает время, которое текущее изменение простояло в очереди на мейн треде UnknownScreenTracker - трекер для экрана с предзагрузкой данных  Понятия:\n screenName - имя экрана, которое обычно передается на этапе создания DI contentType - название потока данных. page - номер страницы. Обычно используется для экранов с бесконечными списками. Отправляется первые пять страниц (page-001..page-005), остальные отправляются как page-etc. Можно опустить. failure - либо failure либо success. Можно использовать свою константу для фейла. SCREEN - константа, которая используется для того, чтобы ScreenInitTracker и ScreenDiInjectTracker работали по умолчанию в режиме для самостоятельного экрана. NO_TIME - константа, которая используется в аргументах фукнций трекинга некоторых трекеров, когда мы хотим отправить данные в statsd, которые получили с прошлого экрана UnknownScreenTracker SUCCESS - дефолтная константа, которая используется в трекерах, которая обозначает, что в текущем потоке данных все операции прошли успешно. Успешно получили данные с сети, например, потом успешно их отрисовали.  В случае ScreenDiInjectTracker и ScreenInitTracker contentType используется для отличения субкомпонента от компонента. Например для экрана-субкомпонета выбора объявления, по которому будет выставляться рейтинг продавцу это будет select-advert. В случае ContentLoadingTracker-ов, ViewDataPreparingTracker, ContentDrawingTracker используется для обозначения потока данных. Например на главной странице это объявления adverts и шорткаты shortcuts.\nПользовательские метрики отправляются только первый раз при трекинге. Этапы работы экрана отправляются каждый раз при вызове соответствующего метода трекинга.\nПримеры вызовов методов трекеров:\ninterface ContentDrawingTracker : Tracker { fun trackContentDrawingTracker(page: Int? = null, failure: Boolean) } //затрекали успешную отрисовку (например, список объявлений) tracker.trackContentDrawingTracker(failure = false) //затрекали неуспешную отрисовку (например, заглушку с предложением повторить запрос) tracker.trackContentDrawingTracker(failure = true) interface ContentLoadingTracker : Tracker { fun trackContentLoading(page: Int? = null, failure: String, durationMs: Long = NO_TIME) } //затрекали успешную отрисовку 1 страницы (например, списка объявлений) tracker.trackContentLoading(page = 1, failure = SUCCESS) //затрекали неуспешную отрисовку 1 страницы (например, заглушку с предложением повторить запрос) tracker.trackContentLoading(page = 1, failure = FAILURE) Типы флоу экранов #  Флоу экранов бывают двух типов: стандартный и с предзагрузкой данных.\nСтандартный флоу экранов #   Пользователь нажимает на кнопку на экране А Создается экран Б (здесь трекаем инициализацию и DI) Экран Б грузит данные (трекаем загрузку потока данных) Экран Б готовит презентационные данные (трекаем подготовку потока данных) Экран Б отрисовывает презентационные данные (трекаем отрисовку потока данных)  Флоу экранов с предзагрузкой #  Этот флоу отличаются от стандартных тем, что данные для отображения экран грузит не сам: данные для экрана грузит какой-либо предшествующий экран.\nЭкран Б из примеров - это экран с предзагрузкой [с экрана А].\nВариант 1\n Пользователь нажимает на кнопку на экране А Экран А грузит данные (Создаем UnknownScreenTracker и трекаем время загрузки данных) Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Пример: пользователь нажимает кнопку \u0026ldquo;разместить объявление\u0026rdquo;. В зависимости от разных условий, пользователя могут отправить на экран размещенного объявления, на экран оплаты размещений или на экран применения дополнительных услуг.\nВариант 2\n Пользователь нажимает на кнопку на экране А Экран А переходит на экран с крутилкой, где это происходит Создаем UnknownScreenTracker и трекаем время инициализации, DI и загрузки данных Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Преимущественно такая логика представлена в iOS-платформе.\nПример с главной страницы #    mermaid.initialize({ flowchart: { useMaxWidth:true } });  graph TD A(Тап по шорткату. Запоминаем дату тача) --|ждем создания экрана| B(ОС создала экран Serp) B --|пошел метод onCreate. Начинаем трекать DI | C(Dependency Injection) C --|Здесь же начинаем трекать Init| D(Init. Закончили трекать когда подключились к презентеру) D -- E(load shortcuts) E -- G(prepare shortcuts) G -- K(draw shortcuts) D -- F(load serp) F -- H(prepare serp - переводим сетевые модели в презентационные) H -- L(draw serp) Как замерять перформанс самостоятельного экрана или субкомпонента #  В dagger dependency понадобится:\ninterface SelectAdvertDependencies : ComponentDependencies { ... fun screenTrackerFactory(): ScreenTrackerFactory fun timerFactory(): TimerFactory } Создаем dagger-модуль, который подключаем к компоненту экрана:\n@Module(includes = [Declarations::class]) object SelectAdvertAnalyticsModule { @Provides @PerFragment @JvmStatic fun providesScreenInitTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenInitTracker { return if (isSubComponent) { screenTrackerFactory.createInitTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createInitTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic internal fun providesScreenDiInjectTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenDiInjectTracker { return if (isSubComponent) { screenTrackerFactory.createDiInjectTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createDiInjectTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic fun providesScreenFlowTrackerProvider( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, factory: TimerFactory ): ScreenFlowTrackerProvider { return screenTrackerFactory.createScreenFlowTrackerProvider( screenName, factory ) } @Module internal interface Declarations { @Binds @PerFragment fun bindSelectAdvertTracker(tracker: SelectAdvertTrackerImpl): SelectAdvertTracker } }  isSubComponent: Boolean - если экран может использоваться как отдельный экран и как субкомпонент, этот флаг подскажет, как правильно настроить трекеры для отправки данных screenName - имя самостоятельного экрана, или родительского в случае субкомпонента. Требует согласования с iOS табличка CONTENT_TYPE_SELECT_ADVERT - строковая константа, которая помогает отличить данные текущего субкомпонента в графане от данных родительского экрана. Если константу не передавать как аргумент функции, то трекеры будут работать как для самостоятельного экрана с именем screenName если ваш экран не будет выступать в качестве субкомпонента, то isSubComponent можно не использовать.  Субкомпоненты удобны, когда вам нужно информацию со всех шагов видеть в одном окне в графане.\nОтличия самостоятельных экранов от субкомпонентов:\n У субкомпонента есть родитель - самостоятельный экран, который передает субкомпоненту собственный screen name. Все запросы на загрузку, подготовку и отрисовку буду относиться к screen name, который передал родитель субкомпонент имеет строковую константу content-type, которая прибавляется при отправке метрик инициализации и DI в statsd, чтобы отличать их от основного экрана У субкомпонентов трекается только абсолютное время DI и инициализации  Создаем абстракцию трекера:\nclass HomeTrackerImpl @Inject constructor( private val flowTrackerProvider: ScreenFlowTrackerProvider private val diInjectTracker: ScreenDiInjectTracker private val initTracker: ScreenInitTracker factory: TimerFactory ) : HomeTracker { private var locationFromSaveLoadTracker: ContentLoadingTracker? = null private var locationLoadTracker: ContentLoadingTracker? = null private var advertsLoadTracker: ContentLoadingTracker? = null private var advertsPrepareTracker: ViewDataPreparingTracker? = null private var advertsDrawingTracker: ContentDrawingTracker? = null private var shortcutsLoadTracker: ContentLoadingTracker? = null private var shortcutsPrepareTracker: ViewDataPreparingTracker? = null private var shortcutsDrawingTracker: ContentDrawingTracker? = null override fun trackDiInject(durationMs: Long) { diInjectTracker.track(durationMs) } override fun startInit() { initTracker.start() } override fun trackInit() { initTracker.trackInit() } override fun startLoadingLocation() { locationFromSaveLoadTracker = flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION_FROM_SAVE).apply { start() } } override fun trackLocationLoadedFromSave(locationIdForLoad: String?) { locationFromSaveLoadTracker?.trackContentLoading(null, SUCCESS) locationFromSaveLoadTracker = null locationLoadTracker = if (locationIdForLoad != null) { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_LOAD_LOCATION) } else { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION) }.apply { start() } } override fun trackLocationLoaded() { locationLoadTracker?.trackContentLoading(null, SUCCESS) locationLoadTracker = null } override fun trackLocationLoadError() { locationLoadTracker?.trackContentLoading(null, FAILURE) locationLoadTracker = null locationFromSaveLoadTracker?.trackContentLoading(null, FAILURE) locationFromSaveLoadTracker = null } override fun startLoadingAdverts() { advertsLoadTracker = flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_ADVERT_ITEMS) .apply { start() } } override fun trackAdvertsLoaded(page: Int) { trackAdvertsLoaded(page, SUCCESS) } override fun trackAdvertsPrepare(page: Int) { trackAdvertsPrepare(page, false) } override fun startAdvertsDraw() { startAdvertsDrawingTracker() } override fun trackAdvertsDraw(page: Int) { trackAdvertsDraw(page, false) } override fun trackAdvertsLoadError(page: Int) { trackAdvertsLoaded(page, FAILURE) } override fun trackAdvertsErrorPrepare(page: Int) { trackAdvertsPrepare(page, true) } override fun trackAdvertsErrorDraw(page: Int) { trackAdvertsDraw(page, true) } private fun trackAdvertsLoaded(page: Int, result: String) { advertsLoadTracker?.trackContentLoading(page, result) advertsLoadTracker = null advertsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsPrepare(page: Int, failure: Boolean) { advertsPrepareTracker?.trackViewDataPreparing(page, failure) advertsPrepareTracker = null } private fun startAdvertsDrawingTracker() { advertsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsDraw(page: Int, failure: Boolean) { advertsDrawingTracker?.trackContentDrawingTracker(page, failure) advertsDrawingTracker = null } override fun startLoadingShortcuts(local: Boolean) { shortcutsLoadTracker = if (local) { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_TYPE_SHORTCUTS) } else { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_SHORTCUTS) }.apply { start() } } override fun trackShortcutsLoaded() { shortcutsLoadTracker?.trackContentLoading(null, SUCCESS) shortcutsLoadTracker = null } override fun startShortcutsPrepare() { shortcutsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsPrepare() { shortcutsPrepareTracker?.trackViewDataPreparing(null, false) shortcutsPrepareTracker = null shortcutsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsDraw() { shortcutsDrawingTracker?.trackContentDrawingTracker(null, false) shortcutsDrawingTracker = null } override fun stopShortcutsLoad() { shortcutsPrepareTracker = null } override fun trackShortcutsLoadError() { shortcutsLoadTracker?.trackContentLoading(null, FAILURE) shortcutsLoadTracker = null } override fun startReloadSession() { stopAllSessions() } override fun startLoadMoreSession() { stopAllSessions() } override fun stopLoadAdvertSession() { stopAllSessions() } Как выглядит трекер с предзагрузкой #  interface UnknownScreenTracker { fun trackInit(durationMs: Long) fun trackDiInject(durationMs: Long) fun startLoading() fun trackLoading() fun toScreenTransfer(): ScreenTransfer } Вариант 1. Необходимо затрекать только loading, потому что экран в целом отдельный и только запрос относится к целевому экрану.\nВариант 2. Необходимо затрекать init, di, loading, потому что экран целиком занимается тем, что выясняет, какой экран будет следующим.\nМетод toScreenTransfer отдает нам объект, хранящий все необходимые данные для передачи целевому экрану:\nclass ScreenTransfer( val initTime: Long, val loadingTime: Long, val diTime: Long ): Parcelable Этот объект необходимо положить в интент для целевого экрана с помощью BaseActivity.saturateIntentWithTrackingInfo\noverride fun followDeepLink(deepLink: DeepLink) { deepLinkIntentFactory.getIntent(deepLink) ?.let { startActivity(saturateIntentWithTrackingInfo(it, tracker.toScreenTransfer())) } } В целевом экране необходимо затрекать эти данные в onCreate:\nif (savedInstanceState == null) { val screenTransfer = rescueScreenTransfer() screenTransfer?.let { tracker.recover(it) } } Код трекера\nclass RatingPublishTrackerImpl @Inject constructor( ... private val recovery: ScreenTransferRecovery ) : RatingPublishTracker { override fun recover(transfer: ScreenTransfer) { recovery.recover(transfer, RATING_PUBLISH_NAME, CONTENT_TYPE_PRELOAD) } CONTENT_TYPE_PRELOAD - константа, которая позволяет правильно затрекать поток данных который был получен на предыдущем экране.\nRATING_PUBLISH_NAME - имя текущего экрана\nВ даггер модуль добавить:\n@Scope: PerActivity, PerFragment @Binds fun bindScreenTransferRecovery(recovery: ScreenTransferRecovery.Impl): ScreenTransferRecovery Как во время разработки проверить, что замеры отправляются #  Можно смотреть лог, в нем будут подобные строчки:\nTIME:android-debug.355.os.29.screen-performance.absolute.SearchResults.-.content-loading-server.advertisements.page-001.Wi-Fi.-.success:992\n android-debug - дебажная версия приложения, в релизной - android 355 - version code 29 - версия ОС SearchResults - screenName, имя экрана content-loading-server - загрузка данных с сервера advertisements - contentType, поток данных - объявления success - запрос закончился успешно 992 - количество миллиисекунд, которые длился запрос  Чтобы посмотреть отсылаемые в графану значения, нужно\n зайти на дашборд В Screen name выбрать имя вашего экрана В Release/debug выбрать android-debug для debug-сборки, и android - для релизной Должны появиться значения на дашбордах  Данные в дашборде отображаются с 30-секундной задержкой через сервис агрегации метрик statsd.\nПример в графане #  Пример с экрана RatingPublish\nВ панели Steps можно увидеть:\n preinit - время от тача по кнопке оставить рейтинг до начала DI экрана с флоу проставления рейтинга. Этот этап включает промежуточный шаг, когда пользователь видел лоадер preload init - этап инициализации экрана RatingPublish di-inject - этап DI экрана RatingPublish load preload - Промежуточный этап, когда пользователь видел лоадер preload. Затрекали с помощью UnknownScreenTracker draw preload - отрисовка данных полученных с прошлого экрана load adverts-list - этап загрузки с сервера списка объявлений на субкомпоненте-фрагменте select-advert (выбор объявления, по которому будет проставляться рейтинг, первый шаг на флоу проставления рейтинга) load next-step - этап загрузки с сервера следующего этапа экрана RatingPublish draw next-step, draw adverts-list - время отрисовки. Не стал отдельно трекать подготовку, ее здесь нет. Если бы залогировал, был бы еще этап подготовки: parse next-step, parse adverts-list component init select-advert - этап инициализации субкомпонента select-advert component di preload, component init preload - затрекали как субкомпонент время инициализации и DI с прошлого экрана component di select-advert - этап DI субкомпонента select-advert  "});index.add({'id':63,'href':'/avito-android/docs/ci/containers/','title':"Сборки в контейнерах",'section':"Docs",'content':"Сборки в контейнерах #  This page contains Avito specific details  Avito Docker documentation (internal)\nВсе образы расположены в ci/docker.\nAndroid SDK image #  This is the base image with Android Build Tools.\nIt\u0026rsquo;s not ready yet, see MBS-7071.\nAndroid builder image #  This is the image for building and testing Android applications. It contains Android SDK.\nHow to update android-builder image? #    Build the image to test your changes In CI Run Build android-builder (internal) teamcity configuration.\nYou will see the tag in stdout:\nImage *******/android/builder:eb4a3b67e564 has been published successfully Locally export DOCKER_REGISTRY=\u0026lt;docker registry\u0026gt; cd ci/docker ./publish.sh \u0026lt;directory with Dockerfile\u0026gt; This script will build a new image. You will the tag in stdout:\nSuccessfully built eb4a3b67e564 To push the image you must have registry credentials in these envs: DOCKER_LOGIN, DOCKER_PASSWORD .\nWithout it the script will stop after building.\n   Upload the image to Docker Hub\n  Update image hash in IMAGE_ANDROID_BUILDER variable in ci shell scripts:\n In github repo: ci/_environment.sh In internal avito repository: ci/_main.sh    Check this images is working. At least, run ci/local_check.sh.\n  Make PR with a new image.\n  Docker in docker image #  Утилитарный образ с докером внутри.\\ Используем внутри скриптов для создания и публикации других образов, прежде всего эмулятора.\nHow to update itself? #  Образ собирает сам себя с помощью предыдущей версии образа (bootstrapping):\n./publish.sh docker-in-docker-image\npublish.sh - использует текущую версию образа\ndocker-in-docker-image - содержит изменения\nЕсли меняем контракт с окружением, то вносим правки поэтапно, чтобы прошлая версия образа могла собрать новую.\nBuild docker-in-docker (internal)\nAndroid emulator images #  Эмуляторы имеют кастомные настройки, оптимизированы для стабильности и производительности.\n Небольшое разрешение экрана: 320x480, 4 inch Отключены многие фичи  Как запустить эмулятор? #  macOS/Windows CI эмулятор невозможно запустить из-за ограничений виртуализации haxm #51. Поэтому воспроизводим идентичную конфигурацию.\n Создай эмулятор в Android Studio: WVGA (Nexus One) с размером экрана 3.4\u0026rsquo;\u0026rsquo; и разрешением 480x800. Запусти эмулятор Настрой параметры:  adb root adb shell \u0026#34;settings put global window_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global transition_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global animator_duration_scale 0.0\u0026#34; adb shell \u0026#34;settings put secure spell_checker_enabled 0\u0026#34; adb shell \u0026#34;settings put secure show_ime_with_hard_keyboard 1\u0026#34; adb shell \u0026#34;settings put system screen_off_timeout 1800000\u0026#34; adb shell \u0026#34;settings put secure long_press_timeout 1500\u0026#34;  Перезагрузи эмулятор  См. все настройки в android-emulator/hardware и android-emulator/prepare_snapshot.sh\nЗадача на автоматизацию (internal)\nLinux Проще и надежнее использовать оригинальные CI эмуляторы.\nТребования:\n  Docker\n  KVM\n  Найди актуальную версию образа в Emulator.kt.\n  Разреши подключение к Xorg серверу с любого хоста (изнутри контейнера в нашем случае):\n  xhost +  Запусти эмулятор:  docker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  -e \u0026#34;SNAPSHOT_DISABLED\u0026#34;=\u0026#34;true\u0026#34; -e \u0026#34;WINDOW\u0026#34;=\u0026#34;true\u0026#34; --volume=\u0026#34;/tmp/.X11-unix:/tmp/.X11-unix:rw\u0026#34; \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt; Или в headless режиме:\ndocker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt;  Подключись к эмулятору в adb  adb connect localhost:5555  Как обновить образ? #  Для эмулятора нужна более сложная подготовка, поэтому используем отдельные скрипты и образы.\n1. Залей образы в приватный Docker registry #  CI  Собери образ на ветке в Teamcity конфигурации Build android-emulator (internal).\nТеги новых образов будут в артефактах сборки. Обнови теги в build.gradle скриптах. Запушь изменение в ветку.  Local Требования:\n Linux, docker KVM K8S права на push образов в registry-mobile-apps (env переменные DOCKER_LOGIN, DOCKER_PASSWORD)   Запусти скрипт:  cd ci/docker ./publish_emulator android-emulator Соберет образ, протестирует и запушит в docker registry.\n Найти новые теги образов. См. stdout скрипта или файл android-emulator/images.txt Обнови теги образов в build.gradle скриптах.   2. Залей образы в Docker hub #  Uploading image to Docker Hub\nКак проверить регрессию? #   Прогони instrumentation dynamic чтобы выявить возможную утечку памяти.\nДля этого запусти компонентный тест с большим числом повторов. Прогони fullCheck\nСравни количество тестов по всем статусам, не стало ли больше упавших или потерянных.  Как проверить сколько ресурсов тратит эмулятор? #  Локально используем cAdvisor\nsudo docker run \\  --volume=/:/rootfs:ro \\  --volume=/var/run:/var/run:ro \\  --volume=/sys:/sys:ro \\  --volume=/var/lib/docker/:/var/lib/docker:ro \\  --volume=/dev/disk/:/dev/disk:ro \\  --publish=8080:8080 \\  --detach=true \\  --name=cadvisor \\  google/cadvisor:latest В CI смотрим в метрики куба.\nDocker Hub #  Образы публикуем в hub.docker.com/u/avitotech.\nUploading image to Docker Hub #  Пока что заливаем вручную, задача на автоматизацию: MBS-8773.\n Залогинься в Docker hub  docker login --username=avitotech --password=... Скачай новый образ из приватного registry  docker pull \u0026lt;DOCKER_REGISTRY\u0026gt;/android/\u0026lt;image\u0026gt;:\u0026lt;DIGEST\u0026gt; Пример:\ndocker pull registry/android/android-emulator-29:c0de63a4cd Поставь образу tag равный digest из приватного registry  docker tag \u0026lt;DIGEST\u0026gt; avitotech/android-emulator-\u0026lt;API\u0026gt;:\u0026lt;DIGEST\u0026gt; Пример:\ndocker tag c0de63a4cd avitotech/android-emulator-29:c0de63a4cd` Tag нужен чтобы ссылаться на образ по одним и тем-же координатам. Digest в разных registry может не совпадать (images ID does not match registry manifest digest).\nЗалей образ  docker push avitotech/android-emulator-\u0026lt;API\u0026gt;:\u0026lt;DIGEST\u0026gt;` Пример:\ndocker push avitotech/android-emulator-29:c0de63a4cd Best practices #  Reproducible image #  Хотим получать одинаковый образ на любой машине, в любом окружении. Это упрощает отладку проблем и делает сборку более надежной.\nreproducible-builds.org\nИсточники нестабильности:\n Не указана явно версия зависимости. Копируем в образ файлы, сгенерированные вне докера.\nГлядя на такие файлы трудно сказать в каком окружении они созданы, какое содержание ожидаемое.  "});index.add({'id':64,'href':'/avito-android/docs/test/screenshottesting/','title':"Скриншотные тесты",'section':"Docs",'content':"Скриншотные тесты #  Цель #  Скриншотные тесты позволяют вовремя отследить изменения цветов / стилей и предотвратить нежелательные изменения в UI\nЧто именно покрывают скриншотные тесты? #  Сейчас скриншотные тесты распространяются только на компоненты из дизайн системы\nОграничения #  В данный момент скриншотные тесты заливаются в git без использования git-lfs. Разумеется, если скриншотов в истории git будет слишком много, то вес репозитория будет слишком большой и работа с ним в целом замедлится. По рассчетам еще не скоро это станет проблемой, договорились что стоит поднимать вопрос после планки в 50 mb\nКак узнать сколько места скриншоты занимают сейчас? #  Следует запустить скрипт, который покажет текущий размер директории, учитывая удаленные и замененные файлы\nПримечание: сейчас в папке со скриншотами так же есть в истории скриншоты старых тестов, занимающие 16 mb\nsh screenshot_test_size.sh Как узнать какие именно файлы были посчитаны? #  Запустить скрипт:\nsh file-sizes.sh Я поменял цвета/стили и теперь скриншотные тесты не проходят на CI, что делать? #    Убедиться что поменялось только то, что нужно.\n  Обязательно добавить @aodanilov и @poignatov в PR\n  (Опционально) удалить папку /design-app/src/androidTest/assets/screenshots\n  Выставить нужный эмулятор локально\nПримечание: просто создать эмулятор не выйдет, так как эмулятор на CI обладает кастомными характеристиками, поэтому нужно взять характеристики для 27 API из /ci/docker/android-emulator/hardware и добавить их в config.ini своего эмулятора, который лежит по адресу ~/.android/avd/\u0026lt;название эмулятора\u0026gt;.avd самое главное - это сделать одинаковыми параметры\nhw.lcd.width\nhw.lcd.height\nhw.lcd.density\nhw.gpu.mode //по умолчанию auto, но этот самый auto может сильно различаться\n  Проверить, что все остальные эмуляторы выключены\n  Перегенерировать скриншоты командой\n  sh record_screenshots.sh  Скриншоты добавятся в папку /design-app/src/androidTest/assets/screenshots/ Можно коммитить их и пушить  Где хранятся скриншоты? #  Скриншоты хранятся в папке /design-app/src/androidTest/assets/screenshots\nВнутри этой папки скриншоты разделяются по папкам далее используя контракт имени API_{API_VERSION}_{WIDTH}x{HEIGHT}_{DENSITY}, на данный момент используется только один эмулятор, соответственно название папки выглядит так: API_27_320x480_120\n"});index.add({'id':65,'href':'/avito-android/docs/externallibrarychangeprocess/','title':"Соглашения по работе с внешними библиотеками",'section':"Docs",'content':"Соглашения по работе с внешними библиотеками #  Описание устарело.\nНужно пересмотреть и перенести на страницу про работу с зависимостями.    Не нужно использовать без необходимости внешние библиотеки - ради абзаца кода нет смысла утяжелять проект\n  Не стоит использовать библиотеки сомнительного качества:\n С низким рейтингом Плохо покрытые тестами Давно не обновляемые Код в которых заведомо низкого качества и т.п.    Наличие или отсутствие каких-либо из этих свойств не является определяющим при выборе библиотеки. Необходимо руководствоваться требованиями разумности и здравого смысла.\n Перед внедрением библиотеки обсуди с коллегами целесообразность. Обрати внимание на качество библиотеки и ее аналогов: завязка на некачественную библиотеку может стать дорогой в поддержке.  Best practices #  Хотим использовать актуальные версии зависимостей.\nВыделили ряд соглашений, чтобы не сломать релиз и упростить обновления:\n Не обновлять много зависимостей в одном ПР. Так повышается скорость локализации некорректно работающей библиотеки в случае обнаружения проблем с приложением. Исключения - семейства сильно связанных библиотек: RxJava и т.п. Обновлять версию библиотеки желательно в начале-середине цикла разработки, а не перед стабилизацией/подготовке к регрессу Не использовать нестабильные версии библиотек (snapshot и тп) Обновлять легкие библиотеки или библиотеки, некорректная работа которых будет заметна сразу (dagger2) рекомендуется на версию, которая является набором багфиксов Не рекомендуется обновлять легкую библиотеку на релиз, в котором есть фичи - это источник потенциально нестабильного кода. Упрощая - библиотеки, версия которых заканчивается на 0 (1.2.0) не стоит интегрировать без определенной надобности - лучше подождать начала следующего цикла разработки Тяжелые библиотеки (Google Play Services, Support Library) нельзя обновлять перед регрессом/стабилизацией. Исключения возможны только в случае, если в версии библиотеки вносятся фиксы, которые решают проблемы текущей подготавливаемой версии. Но и в этом случае не рекомендуется ставить версию библиотеки, которая не является набором багфиксов. Такие библиотеки в конце цикла разработки могут версионироваться только по консенсусному согласию с коллегами о необходимости интеграции конкретной версии  "});})();